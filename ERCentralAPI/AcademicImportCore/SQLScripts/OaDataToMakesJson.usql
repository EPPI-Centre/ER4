//////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                
//  Copyright (c) Microsoft Corporation. All rights reserved.                                     
//  Licensed under the MIT License.                                                               
//                                                                                                
//////////////////////////////////////////////////////////////////////////////////////////////////
// Last Updated: 2020-04-17
//////////////////////////////////////////////////////////////////////////////////////////////////

// Enables OUTPUT statements to generate dynamic files using column values
SET @@FeaturePreviews = "DataPartitionedOutput:on"; 

///////////////////////////////////////////////////////////////////////////////////////////////////
// Input Parameters                                                
//
// Input parameters that can be overridden by instantiating scripts                               
// See: https://docs.microsoft.com/en-us/u-sql/variables/declare-variables for details
///////////////////////////////////////////////////////////////////////////////////////////////////

// The wasb path to a MAG release on Azure storage.
DECLARE EXTERNAL @In_MagRootUri string = "wasb://open-alex@eppimag/2021-11-08/"; //Example: "wasb://open-alex@eppimag/2021-11-08/"

// The storage output path where the JSON files will be created
// The if the output destination type is Azure storage (output path starts with "wasb"), the container for the output location needs to be created before running the script
DECLARE EXTERNAL @Out_OutputPath string = "wasb://open-alex@eppimag/makes/2021-11-08/microsoft/entities";  // Example: "wasb://open-alex@eppimag/makes/2021-11-08/microsoft/entities"

//The name of the institution to create subgraph for. The full graph is used by default.
DECLARE EXTERNAL @Param_UseSubgraphForInstitution string = "microsoft"; // Example: "microsoft"

DECLARE EXTERNAL @Param_UseSubgraphForPapers bool = true;

// U-SQL string values have a maximum length of 2^17, which unfortunately this means we need to limit the number of authors for a paper as they
// are concatenated together into a single JSON array represented by a U-SQL string.
//
// We can somewhat get around this by splitting JSON arrays across multiple columns and having those columns be joined during
// the final JSON output by a tab delimited (which JSON ignores), however we need each different entity JSON table to have a fixed number
// of columns otherwise we can't union them, which means we have to have a fixed number of these "paper author" columns.
//
// The value below represents the number of paper authors that are generated for each of the two columns we create for this purpose.
DECLARE EXTERNAL @Param_MaximumPaperAuthorPerBucket int = 250;

// Citation contexts hit a similar issue as the paper author issue describe above, related to the maximum string length U-SQL allows.
//
// Unfortunately citation contexts do not have a maximum length in MAG, so can be quite long. Adding to this problem, MAG does not limit the 
// number of citation contexts it makes available for each paper.
//
// Both of these issues combined means we need to use both a maxmimum individual citation context length and a maximum number of allowed citation contexts per paper
// The number of citation context generated for each of the two column buckets
//DECLARE EXTERNAL @Param_MaximumCitationContextPerBucket int = 100;

// The max citation context length for each context
//DECLARE EXTERNAL @Param_MaximumCitationContextLength int = 200;

//The max citation contexts for each cited paper
//DECLARE EXTERNAL @Param_MaximumCitationContextPerCitation int = 5;

// The max number of field of study children to include for a field of study entity
DECLARE EXTERNAL @Param_MaximumFieldOfStudyChildrenCount int = 200;

// The max number of field of study parent to include for a field of study entity
DECLARE EXTERNAL @Param_MaximumFieldOfStudyParentCount int = 200;

//The max number of reference to include for a paper entity
DECLARE EXTERNAL @Param_MaximumReferencesPerPaper int = 500;

// The number of files to partition the data into
DECLARE EXTERNAL @Param_PartitionCount int = 16;

////////////////////////////////////////////////////////////////////////////////////////////////////
// Local variables
//
// Local varibles and functions used for the script execution
////////////////////////////////////////////////////////////////////////////////////////////////////

// Full output path w/file name pattern reflecting the PartitionNumber column in the table that gets output
DECLARE @outputFilePattern string = @Out_OutputPath + "/{PartitionNumber}.json";

// A unique string used as seperator for joining multiple columns/data into a single string
DECLARE @DEFAULT_SEPERATOR = @"@?@al@?@";

// Default seperator string array for string split operation
DECLARE @DEFAULT_STRING_ARRAY_SEPERATOR = new string[] {@DEFAULT_SEPERATOR};

// Utility function to get a uint? item from a item array joined by DEFAULT_STRING_ARRAY_SEPERATOR as string
DECLARE @GetNullableUintItem Func<string, int, uint?>  = 
	(str, itemIndex) => {
		string[] items = str.Split(@DEFAULT_STRING_ARRAY_SEPERATOR, StringSplitOptions.None);
		if (itemIndex < 0 || items[itemIndex].Length == 0)
		{
			return null;
		}
		else 
		{
			return uint.Parse(items[itemIndex]);
		}
	};

// Utility function to get a long? item from a item array joined by DEFAULT_STRING_ARRAY_SEPERATOR as string
DECLARE @GetNullableLongItem Func<string, int, long?>  = 
	(str, itemIndex) => {
		string[] items = str.Split(@DEFAULT_STRING_ARRAY_SEPERATOR, StringSplitOptions.None);
		if (itemIndex < 0 || items[itemIndex].Length == 0)
		{
			return null;
		} 
		else 
		{
			return long.Parse(items[itemIndex]);
		}
	};

// Utility function to get a float? item from a item array joined by DEFAULT_STRING_ARRAY_SEPERATOR as string
DECLARE @GetNullableFloatItem Func<string, int, float?> =
	(str, itemIndex) => {
		string[] items = str.Split(@DEFAULT_STRING_ARRAY_SEPERATOR, StringSplitOptions.None);
		if (itemIndex < 0 || items[itemIndex].Length == 0)
		{
			return null;
		} 
		else 
		{
			return float.Parse(items[itemIndex]);
		}
	};

// Utility function to get a string item from a item array joined by DEFAULT_STRING_ARRAY_SEPERATOR as string
DECLARE @GetStringItem Func<string, int, string> =
	(str, itemIndex) => {
		if (itemIndex < 0)
		{
			return null;
		} 
		string[] items = str.Split(@DEFAULT_STRING_ARRAY_SEPERATOR, StringSplitOptions.None);
		return items[itemIndex];
	};

// ******************* new function to remove crazy characters ********************
//DECLARE @RemoveCrazyCharacters Func<string, string> =
//	(input) => input.Replace("@*%!", "");

// Utility function for escaping a JSON string
DECLARE @jsonEscapeString Func<string, string> = 
	(input) => input.Replace("\\", "\\\\").Replace("\"", "\\\"");

// Utility function that generates JSON for an JSON object attribute (name + value) w/o any special considersation for the value type
DECLARE @JsonRawAttribute Func<string, string, string>  = 
	(name, value) => "\"" + name + "\":" + value;

// Utility function that generates JSON for a JSON object string attribute (name + value), doing the additional work of escaping the string
DECLARE @JsonStringAttribute Func<string, string, string> =
	(name, value) => @JsonRawAttribute(name, "\"" + @jsonEscapeString(value) + "\"");

// Utility function that generates appropriate JSON for a JSON object attribute (name + value) by first checking the values type
DECLARE @JsonAttribute Func<string, object, string> =
	(name, value) =>
	{
		if(value is string)
		{
			return @JsonStringAttribute(name, (string)value);
		}
		else
		{
			return @JsonRawAttribute(name, value.ToString());
		}
	};

// Utility function that generates a JSON object by joining a list of JSON attributes
DECLARE @JsonObjectFromAttributes Func<IEnumerable<string>, string> =
	(attributes) =>
	{
		return "{" + string.Join(",", attributes.Where(attribute => attribute != null)) + "}";
	};

// Utility function that returns a JSON string array representing the unique words found in a string
DECLARE @GenerateUniqueStringWords Func<string, string> = 
	(input) => "[" + string.Join(",", new HashSet<string>(input.Split(' ')).Select(word => "\"" + word + "\"")) + "]";

// Utility function that returns the enum int value as string for publication doc type
DECLARE @GetPublicationTypeValueFromString Func<string, string> =
	(docTypeString) =>
	{
		switch (docTypeString)
		{
			case "Journal":
				return "1";
			case "Patent":
				return "2";
			case "Conference":
				return "3";
			case "BookChapter":
				return "4";
			case "Book":
				return "5";
			case "BookReferenceEntry":
				return "6";
			case "Dataset":
				return "7";
			case "Repository":
				return "8";
			default:
				return "0";
		}
	};

// Utility function that converts the inverted abstract JSON into a simple string containing all normalized abstract words
DECLARE @GenerateAbstractWords Func<string,string> = (invertedAbstract) => 
{
    if(string.IsNullOrEmpty(invertedAbstract))
    {
        return "";
    }
    
    // The inverted abstract is serialized JSON of a list of abstract word to abstract position (index), i.e. ["word1": [1,5,50], "word2": [2,90], ...]
    // To avoid having to leverage external code for parsing JSON, use a simple regular expression to extract all strings
    string abs = string.Join(
                " ",
                Regex
                .Matches(invertedAbstract, "\\\"(.*?)\\\"")
                .Cast<Match>()
                .Select(match => match.Groups[1].Value));
    
    
    // Trim and normalize the resulting string
    return 
        Regex
        
        // Reduce all instances of 1+ spaces to a single space
        .Replace(
            Regex
            // Replace all non-alphanumeric characters with a space
            .Replace(abs, "[^\\d\\w]", " ")
            
            // Trim the two JSON object names that are picked up
            .Replace("IndexLength InvertedIndex ", ""), 
            
            "\\s+", " ")
            
        // Convert to lowercase
        .ToLower();
};

// Utility to convert MAG entity rank to log probability
DECLARE @GetLogProbabilityFromRank Func<uint?, double?> =
	(weight) =>
	{
		return  -0.001 * weight;
	};


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Data Extraction
//
// Load academic data using official MAG table functions                                                                                         
// See https://docs.microsoft.com/en-us/academic-services/graph/tutorial-azure-data-lake-hindex#define-functions-to-extract-mag-data for details 
//                                                                                                                                               
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@affiliations =
	Affiliations
	(
		@In_MagRootUri
	);
@authors =
	Authors
	(
		@In_MagRootUri
	);
//@fieldOfStudyChildren =
//	FieldOfStudyChildren
//	(
//		@In_MagRootUri
//	);
@fieldsOfStudy =
	FieldsOfStudy
	(
		@In_MagRootUri
	);
@journals =
	Journals
	(
		@In_MagRootUri
	);
@paperAbstractsInvertedIndex =
	SELECT *,
           @GenerateUniqueStringWords(@GenerateAbstractWords(IndexedAbstract)) AS AbstractWords
	FROM
	PaperAbstractsInvertedIndex
	(
		@In_MagRootUri
	);
@paperAuthorAffiliations =
	PaperAuthorAffiliations
	(
		@In_MagRootUri
	);
@paperFieldsOfStudy =
	PaperFieldsOfStudy
	(
		@In_MagRootUri
	);
@paperReferences =
	PaperReferences
	(
		@In_MagRootUri
	);
@paperUrls =
	PaperUrls
	(
		@In_MagRootUri
	);
@papers =
	Papers
	(
		@In_MagRootUri
	);

// **************** clean up nullable longs *************************


@affiliations =
	SELECT
		@affiliations.AffiliationId,
		@affiliations.Rank,
		@affiliations.NormalizedName,
		@affiliations.DisplayName,
		@affiliations.GridId,
		@affiliations.RorId,
		@affiliations.OfficialPage,
		@affiliations.WikiPage,
		@affiliations.PaperCount == null? (long) 0 : (long) @affiliations.PaperCount AS PaperCount,
		@affiliations.PaperFamilyCount == null? (long) 0 : (long) @affiliations.PaperFamilyCount AS PaperFamilyCount,
		@affiliations.CitationCount == null? (long) 0 : (long) @affiliations.CitationCount AS CitationCount,
		@affiliations.Iso3166Code,
		@affiliations.Latitude,
		@affiliations.longitude,
		@affiliations.CreatedDate,
		@affiliations.UpdatedDate
	FROM @affiliations;

@authors =
	SELECT
		@authors.AuthorId,
		@authors.Rank,
		@authors.NormalizedName,
		@authors.DisplayName,
		@authors.Orcid,
		(@authors.LastKnownAffiliationId == null? (long) -1 : (long) @authors.LastKnownAffiliationId) AS LastKnownAffiliationId,
		(@authors.PaperCount == null? (long) 0 : (long) @authors.PaperCount) AS PaperCount,
		(@authors.PaperFamilyCount == null? (long) 0 : (long) @authors.PaperFamilyCount) AS PaperFamilyCount,
		(@authors.CitationCount == null? (long) 0 : (long) @authors.CitationCount) AS CitationCount,
		@authors.CreatedDate,
		@authors.UpdatedDate
	FROM @authors;

@papers =
	SELECT
		@papers.PaperId,
    	@papers.Rank,
    	@papers.Doi,
    	@papers.DocType,
    	@papers.Genre,
    	@papers.IsParatext,
    	@papers.PaperTitle,
    	@papers.OriginalTitle,
    	@papers.BookTitle,
    	(@papers.Year == null ? (int) 0 : (int) @papers.Year) AS Year,
    	@papers.Date,
    	@papers.OnlineDate,
    	@papers.Publisher,
    	(@papers.JournalId == null ? (long?) - 1 : (long?) JournalId) AS JournalId,
    	0 AS ConferenceSeriesId,
    	0 AS ConferenceInstanceId,
    	@papers.Volume,
    	@papers.Issue,
    	@papers.FirstPage,
    	@papers.LastPage,
    	(@papers.ReferenceCount == null ? (long) 0 : (long) ReferenceCount) AS ReferenceCount,
        (@papers.CitationCount == null ? (long) 0 : (long) CitationCount) AS CitationCount,
        (@papers.EstimatedCitation == null ? (long) 0 : (long) EstimatedCitation) AS EstimatedCitation,
    	@papers.OriginalVenue,
        (@papers.FamilyId == null ? (long) 0 : (long) FamilyId) AS FamilyId,
    	@papers.FamilyRank,
    	@papers.DocSubTypes,
    	@papers.OaStatus,
    	@papers.BestUrl,
    	@papers.BestFreeUrl,
    	@papers.BestFreeVersion,
    	@papers.DoiLower,
    	@papers.CreatedDate,
    	@papers.UpdatedDate
	FROM @papers;

@journals =
	SELECT
		@journals.JournalId,
		@journals.Rank,
		(@journals.NormalizedName == null ? (string) "" : (string) @journals.NormalizedName) AS NormalizedName,
		@journals.DisplayName,
		@journals.Issn,
		@journals.Issns,
		@journals.IsOa,
		@journals.IsInDoaj,
		@journals.Publisher,
		@journals.Webpage,
		@journals.PaperCount,
		@journals.PaperFamilyCount,
		@journals.CitationCount,
		@journals.CreatedDate,
		@journals.UpdatedDate
	FROM @journals;

@fieldsOfStudy = 
	SELECT
		FieldOfStudyId,
		Rank,
		NormalizedName,
		DisplayName,
		MainType,
		(Level == null ? (int) 0 : (int) Level) AS Level,
		(PaperCount == null ? (long) 0 : (long) PaperCount) AS PaperCount,
		PaperFamilyCount,
		CitationCount,
		CreatedDate
	FROM @fieldsOfStudy;


// Generate additional non-nullable columns for specific columns in the default MAG databases.
// This is required for table join operations later in this script.
@authors =
	SELECT *,
			(LastKnownAffiliationId == null ? (long) - 1 : LastKnownAffiliationId) AS _LastKnownAffiliationId
	FROM @authors;

@paperAuthorAffiliations =
	SELECT *,
			(AffiliationId == null ? (long) - 1 : (long) AffiliationId) AS _AffiliationId
	FROM @paperAuthorAffiliations;

@papers =
	SELECT *,
			(JournalId == null ? (long) - 1 : (long) JournalId) AS _JournalId // was JournalId.Value
	FROM @papers;



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Subgraph Creation                  *********************** ALL REMOVED FOR OPENALEX *********************                                         
// 
// Apply filtering logic to create a subgraph from MAG.
// The example below illustrates the graph filtering logic based on papers published by an affiliation.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

IF !string.IsNullOrEmpty(@Param_UseSubgraphForInstitution) THEN
	@paperAuthorAffiliations = 
		SELECT @paperAuthorAffiliations.*
		FROM @paperAuthorAffiliations
			INNER JOIN
					@affiliations
				ON @paperAuthorAffiliations._AffiliationId == @affiliations.AffiliationId
		WHERE @affiliations.NormalizedName == @Param_UseSubgraphForInstitution;
END;

//IF !string.IsNullOrEmpty(@Param_UseSubgraphForPapers) THEN
//	@papers =
//		SELECT @papers.*
//		FROM @papers
//        ORDER BY @papers.PaperId
//		FETCH FIRST 10000 ROWS; 

//@fieldOfStudyChildren =
//	SELECT 
//		Fc.FieldOfStudyId AS ParentId,
//		Fc.ChildFieldOfStudyId AS ChildId,
//		
//		//Using display name for backwards compatibility. Not a bug
//		Fr.DisplayName AS ChildName,
//		Fl.DisplayName AS ParentName
//	FROM @fieldOfStudyChildren AS Fc
//		INNER JOIN
//			@fieldsOfStudy AS Fl
//		ON Fc.FieldOfStudyId == Fl.FieldOfStudyId
//		INNER JOIN
//			@fieldsOfStudy AS Fr
//		ON Fc.ChildFieldOfStudyId == Fr.FieldOfStudyId;

// Reduce field of study children data to create field childs per field of study
//@reducedFieldOfStudyChildren =
//	SELECT 
//		ParentId AS FieldOfStudyId,
//		
//		// Reduce the rows into a string representation of a list of fields of study json objects
//		string.Join(
//			",",
//			ARRAY_AGG(
//			@JsonObjectFromAttributes(new string[]{ 
//					@JsonAttribute("FId", ChildId),
//					@JsonAttribute("FN", ChildName)
//			}))
//		.Take(@Param_MaximumFieldOfStudyChildrenCount)) AS FieldOfStudyChildren
//	FROM @fieldOfStudyChildren
//	GROUP BY ParentId;

// Reduce field of study children data to create field parents per field of study
//@reducedFieldOfStudyParents =
//	SELECT 
//		ChildId AS FieldOfStudyId,
//		
//		// Reduce the rows into a string representation of a list of fields of study json objects
//		string.Join(
//			",",
//			ARRAY_AGG(
//			@JsonObjectFromAttributes(new string[]{ 
//					@JsonAttribute("FId", ParentId),
//					@JsonAttribute("FN", ParentName)
//			}))
//		.Take(@Param_MaximumFieldOfStudyParentCount)) AS FieldOfStudyParents
//	FROM @fieldOfStudyChildren
//	GROUP BY ChildId;



///////////////////////////////////////////////////////////////////////////////
// Filter and reduce paper author data into a single attribute for each paper
///////////////////////////////////////////////////////////////////////////////
@paperAuthorAffiliations =
	SELECT 
		@paperAuthorAffiliations.PaperId,
		@paperAuthorAffiliations.AuthorId,
		@paperAuthorAffiliations.OriginalAuthor,
		//@paperAuthorAffiliations.AffiliationId,
        @paperAuthorAffiliations.AffiliationId == null? (long) 0 : (long) @paperAuthorAffiliations.AffiliationId AS AffiliationId,
		@paperAuthorAffiliations._AffiliationId,
		@paperAuthorAffiliations.OriginalAffiliation,

		// NOTE: Casting AuthorSequenceNumber to nullable as MAP_AGG requires it
		//((uint?) @paperAuthorAffiliations.AuthorSequenceNumber) AS AuthorSequenceNumber
        @paperAuthorAffiliations.AuthorSequenceNumber == null? (int) 0 : (int) @paperAuthorAffiliations.AuthorSequenceNumber AS AuthorSequenceNumber
	FROM @paperAuthorAffiliations;

@paperAuthorAffiliations =
	SELECT 
		@paperAuthorAffiliations.PaperId,
		@paperAuthorAffiliations.AuthorId,
		@authors.NormalizedName AS AuthorName,
		!String.IsNullOrEmpty(@paperAuthorAffiliations.OriginalAuthor) ? @paperAuthorAffiliations.OriginalAuthor : @authors.DisplayName AS DisplayAuthorName,
		@paperAuthorAffiliations.AffiliationId,
		@affiliations.NormalizedName AS AffiliationName,
		!String.IsNullOrEmpty(@paperAuthorAffiliations.OriginalAffiliation) ? @paperAuthorAffiliations.OriginalAffiliation : @affiliations.DisplayName AS DisplayAffiliationName,
		@paperAuthorAffiliations.AuthorSequenceNumber AS Sequence
	FROM @paperAuthorAffiliations
		INNER JOIN
			@authors
		ON @paperAuthorAffiliations.AuthorId == @authors.AuthorId
		LEFT OUTER JOIN
			@affiliations
		ON @paperAuthorAffiliations._AffiliationId == @affiliations.AffiliationId;

// U-SQL has a maximum string size limitation of 131072 characters, which causes script errors for attributes that have a lot of values such as this.
// To get around the issue we split the data into multiple buckets which will be output as separate columns in the final JSON output.
@reducedPaperAuthorAffiliations =
	SELECT 
		PaperId,

		// Reduce the rows in paperAuthorAffiliations into a list of key/value pairs, with the key containing the JSON representation of the author/affiliation
		SqlMap.Create(MAP_AGG(          
			@JsonObjectFromAttributes(new string[]{ 
				@JsonAttribute("AuId", AuthorId),
				@JsonAttribute("AuN", AuthorName),
				@JsonAttribute("DAuN", DisplayAuthorName),
				@JsonAttribute("S", Sequence),
				AffiliationId == null ? null : @JsonAttribute("AfId", AffiliationId),
				string.IsNullOrEmpty(AffiliationName) ? null : @JsonAttribute("AfN", AffiliationName),
				string.IsNullOrEmpty(DisplayAffiliationName) ? null : @JsonAttribute("DAfN", DisplayAffiliationName)
			}),
		Sequence + @DEFAULT_SEPERATOR + AffiliationId)) AS AuthorAffiliations
	FROM @paperAuthorAffiliations
	GROUP BY PaperId;



///////////////////////////////////////////////////////////////////////////////////////
// Filter and reduce paper citation contexts into a single attribute for each paper  ************* ALL REMOVED *************
///////////////////////////////////////////////////////////////////////////////////////

				
///////////////////////////////////////////////////////////////////////////////////////
// Filter and reduce paper field of study data into a single attribute for each paper
///////////////////////////////////////////////////////////////////////////////////////
@paperFieldsOfStudy =
	SELECT 
		@paperFieldsOfStudy.PaperId,
		@paperFieldsOfStudy.FieldOfStudyId,
		@fieldsOfStudy.NormalizedName AS FieldOfStudyName,
		@fieldsOfStudy.DisplayName AS DisplayFieldOfStudyName,
		@fieldsOfStudy.Rank
	FROM @paperFieldsOfStudy
			INNER JOIN
				@fieldsOfStudy
			ON @paperFieldsOfStudy.FieldOfStudyId == @fieldsOfStudy.FieldOfStudyId;

@reducedPaperFieldsOfStudy =
	SELECT 
		PaperId,

		// Reduce the rows into a string representation of a list fields of study json objects
		string.Join(",", MAP_AGG(
			@JsonObjectFromAttributes(new string[]{ 
				@JsonAttribute("FId", FieldOfStudyId),
				@JsonAttribute("FN", FieldOfStudyName),
				@JsonAttribute("DFN", DisplayFieldOfStudyName)
			}),
		
			// use these fields as sort key to produce deterministic output
			DisplayFieldOfStudyName + @DEFAULT_SEPERATOR + Rank + @DEFAULT_SEPERATOR + FieldOfStudyId
			).OrderByDescending(fos => @GetStringItem(fos.Value, 0))
			.ThenByDescending(fos => @GetNullableUintItem(fos.Value, 1))
			.ThenBy(fos => @GetNullableLongItem(fos.Value, 2))

			// Once sorted, return only the reduced JSON string
			.Select(fieldOfStudy => fieldOfStudy.Key)) AS FieldsOfStudy
	FROM @paperFieldsOfStudy
	GROUP BY PaperId;

//////////////////////////////////////////////////////////////////////////////
// Filter and reduce paper references into a single attribute for each paper
//////////////////////////////////////////////////////////////////////////////
@paperReferences =
	SELECT 
		@paperReferences.PaperId,
		@paperReferences.PaperReferenceId,
		p2.Rank
	FROM @paperReferences
		LEFT SEMIJOIN
			@papers AS p1
		ON @paperReferences.PaperId == p1.PaperId
		INNER JOIN
			@papers AS p2
		ON @paperReferences.PaperReferenceId == p2.PaperId;

@reducedPaperReferences =
	SELECT 
		PaperId,

		// Reduce the rows into a list of key/value pairs, with the key containing the JSON representation 
		string.Join(",", MAP_AGG(PaperReferenceId, Rank + @DEFAULT_SEPERATOR + PaperReferenceId)
			
		// Order by score, stored in the value of the key/value pair
		.OrderBy(referencedPaper => @GetNullableUintItem(referencedPaper.Value, 0))
		.ThenBy(referencedPaper => @GetNullableLongItem(referencedPaper.Value, 1))
		.Take(@Param_MaximumReferencesPerPaper)

		// Once sorted, return only the reduced JSON string
		.Select(referencedPaper => referencedPaper.Key)) AS References
	FROM @paperReferences
	GROUP BY PaperId;

////////////////////////////////////////////////////////////////////////
// Filter and reduce paper urls into a single attribute for each paper
////////////////////////////////////////////////////////////////////////
@paperUrls =
	SELECT 
		@paperUrls.PaperId,
		@paperUrls.SourceType,
		@paperUrls.SourceUrl
	FROM @paperUrls
			LEFT SEMIJOIN
				@papers
			ON @paperUrls.PaperId == @papers.PaperId;

@reducedPaperUrls =
	SELECT 
		PaperId,

		// Reduce the rows into a single JSON string
		string.Join(",", MAP_AGG(
			@JsonObjectFromAttributes(new string[]{
				(SourceType == null || SourceType == 0) ? null : @JsonAttribute("Ty", SourceType),
				@JsonAttribute("U", SourceUrl)
			}),
			SourceType + @DEFAULT_SEPERATOR + SourceUrl)
			.OrderByDescending( source => @GetStringItem(source.Value, 0))
			.ThenBy( source => @GetStringItem(source.Value, 1))
			.Select( source => source.Key)) AS Urls
	FROM @paperUrls
	GROUP BY PaperId;

////////////////////////////////////////////////////////////////////////
// Aggregate estimated citation counts for each entity
////////////////////////////////////////////////////////////////////////

//Journal
//@journalEstimatedCitationCount = 
//	SELECT 
//		(long)@papers.JournalId AS JournalId,
//		(int) SUM(@papers.EstimatedCitation) AS EstimatedCitationCount
//	FROM @papers
//	WHERE JournalId != null
//	GROUP BY @papers.JournalId;

//Affiliation = removed for eppi-reviewer purposes as we don't use this stat
//@paperAffiliations =
//		SELECT DISTINCT 
//			@paperAuthorAffiliations.AffiliationId AS AffiliationId,
//			@paperAuthorAffiliations.PaperId AS PaperId
//		FROM @paperAuthorAffiliations
//		WHERE @paperAuthorAffiliations.AffiliationId != null;

//@paperStatsAffiliations =
//	SELECT 
//		@paperAffiliations.AffiliationId,
//		@papers.EstimatedCitation
//	FROM @paperAffiliations
//	INNER JOIN
//		@papers
//	ON @paperAffiliations.PaperId == @papers.PaperId;
//
//@affiliationEstimatedCitationCount =
//	SELECT 
//		(long)@paperStatsAffiliations.AffiliationId AS AffiliationId,
//		(int) SUM(@paperStatsAffiliations.EstimatedCitation) AS EstimatedCitationCount
//	FROM @paperStatsAffiliations
//	GROUP BY @paperStatsAffiliations.AffiliationId;

//Author
//@paperAuthors =
//	SELECT DISTINCT 
//		@paperAuthorAffiliations.AuthorId,
//		@paperAuthorAffiliations.PaperId
//	FROM @paperAuthorAffiliations;

//@paperStatsAuthors =
//	SELECT 
//		@paperAuthors.AuthorId,
//		(int) 0 AS EstimatedCitationCount //@papers.EstimatedCitation AS EstimatedCitationCount
//	FROM @paperAuthors
//	INNER JOIN
//		@papers
//	ON @paperAuthors.PaperId == @papers.PaperId;

//@authorEstimatedCitationCount =
//	SELECT 
//		AuthorId,
//		(int) 0 //(int) SUM(@paperStatsAuthors.EstimatedCitationCount) AS EstimatedCitationCount
//	FROM @paperStatsAuthors
//	GROUP BY AuthorId;

//Fields of study
//@paperStatsFieldsOfStudy =
//	SELECT 
//		@paperFieldsOfStudy.FieldOfStudyId,
//		@papers.EstimatedCitation        
//	FROM @paperFieldsOfStudy
//	INNER JOIN
//		@papers
//	ON @paperFieldsOfStudy.PaperId == @papers.PaperId;

//@fieldOfStudyEstimatedCitationCount =
//	SELECT FieldOfStudyId,               
//			(int) 0 //(int) SUM(@paperStatsFieldsOfStudy.EstimatedCitation) AS EstimatedCitationCount
//	FROM @paperStatsFieldsOfStudy
//	GROUP BY FieldOfStudyId;   

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Entity json generation
//
// Generate tables for each entity type that we want to index in MAKES. Note that each table must have        
// the exact same number of columns as we union the tables together before generating the final JSON files.   
//                                                                                                            
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@paperJson =
	SELECT 
		(int) (P.PaperId % @Param_PartitionCount) AS PartitionNumber,
		"{" AS Column001,
		@JsonAttribute("logprob", @GetLogProbabilityFromRank(P.Rank)) + "," AS Column002,
		@JsonAttribute("Id", P.PaperId) + "," AS Column003,
		(string.IsNullOrEmpty(P.Doi) ? "" : @JsonAttribute("DOI", P.Doi) + ",") AS Column004,           
		@JsonAttribute("Pt", @GetPublicationTypeValueFromString(P.DocType)) + "," AS Column005,
		@JsonAttribute("Ti", P.PaperTitle) + "," AS Column006,
		@JsonRawAttribute("W", @GenerateUniqueStringWords(P.PaperTitle)) + "," AS Column007,
		@JsonAttribute("DN", P.OriginalTitle) + "," AS Column008,           
		(Abs.IndexedAbstract == null ? "" : @JsonRawAttribute("IA", Abs.IndexedAbstract) + ",") AS Column009,
		(P.Year == null ? "" : @JsonAttribute("Y", P.Year) + ",") AS Column010, // was P.Year.Value - but removed as year is definitely an int now
		(P.Date == null ? "" : @JsonAttribute("D", P.Date.Value.ToString("yyyy-MM-dd")) + ",") AS Column011,
		@JsonAttribute("CC", P.CitationCount) + "," AS Column012,
		@JsonAttribute("ECC", P.EstimatedCitation) + "," AS Column013,
								
		//Advanced information
		(Urls.Urls == null ? "" : "\"S\":[" + Urls.Urls + "],") AS Column014,
		(F.FieldsOfStudy == null ? "" : "\"F\":[" + F.FieldsOfStudy + "],") AS Column015,
		
		//Journal information
		((P.JournalId == null || P.JournalId == -1) ? "" : @JsonRawAttribute("J", @JsonObjectFromAttributes(new string[]{ 
			@JsonAttribute("JId", P.JournalId.Value), // WAS P.JournalId.Value
			@JsonAttribute("JN", J.NormalizedName)
		})) + ",") AS Column016,
		(string.IsNullOrEmpty(P.Publisher) ? "" : @JsonAttribute("PB", P.Publisher) + ",") AS Column017,
		(string.IsNullOrEmpty(P.Volume) ? "" : @JsonAttribute("V", P.Volume) + ",") AS Column018,
		(string.IsNullOrEmpty(P.Issue) ? "" : @JsonAttribute("I", P.Issue) + ",") AS Column019,
		(string.IsNullOrEmpty(P.FirstPage) ? "" : @JsonAttribute("FP", P.FirstPage) + ",") AS Column020,
		(string.IsNullOrEmpty(P.LastPage) ? "" : @JsonAttribute("LP", P.LastPage) + ",") AS Column021,
		"" AS Column022,
        "" AS Column023,
        "" AS Column024,
		// Author affiliations
		(A.AuthorAffiliations == null ? "" : "\"AA\":[") AS Column025,
		
		//There may be too many author affiliations to fit in a single column. Split it into two buckets
		(A.AuthorAffiliations == null ? "" :
			string.Join(",", A.AuthorAffiliations
			
			// Order by author sequence number, stored in the value of the key/value pair
			.OrderBy(authorAffiliation => @GetNullableUintItem(authorAffiliation.Value, 0))
			.ThenBy(authorAffiliation => @GetNullableLongItem(authorAffiliation.Value, 1))
			.Take(@Param_MaximumPaperAuthorPerBucket)
			.Select(authorAffiliation => authorAffiliation.Key)
			)) AS Column026,

		//The second bucket for the author affiliations if needed. 
		(A.AuthorAffiliations == null || A.AuthorAffiliations.Count() <= @Param_MaximumPaperAuthorPerBucket ? "" : "," +
			string.Join(",", A.AuthorAffiliations
			.OrderBy(authorAffiliation => @GetNullableUintItem(authorAffiliation.Value, 0))
			.ThenBy(authorAffiliation => @GetNullableLongItem(authorAffiliation.Value, 1))
			.Skip(@Param_MaximumPaperAuthorPerBucket)
			.Take(@Param_MaximumPaperAuthorPerBucket)
			.Select(authorAffiliation => authorAffiliation.Key))) AS Column027,
		(A.AuthorAffiliations == null ? "" : "],") AS Column028,
		
		//References
		(Ref.References == null?"" : "\"RId\":[" + Ref.References + "],") AS Column029,
        
        "" AS Column030,
        "" AS Column031,
        "" AS Column032,
        "" AS Column033,

		(P.FamilyId == null) ? "" : (@JsonAttribute("FamId", P.FamilyId) + ",") AS Column034,
        (string.IsNullOrEmpty(Abs.AbstractWords) || Abs.AbstractWords == "[]"? "" : @JsonRawAttribute("AW", Abs.AbstractWords) + ",") AS Column035,
		"" AS Column036,
		"" AS Column037,
		@JsonAttribute("Ty", "0") AS Column038,
		"}" AS Column039,
        "" AS Column040
	FROM @papers AS P
			LEFT OUTER JOIN
				@journals AS J
			ON P._JournalId == J.JournalId // P.JournalId
			LEFT OUTER JOIN
				@paperAbstractsInvertedIndex AS Abs
			ON P.PaperId == Abs.PaperId
			LEFT OUTER JOIN
				@reducedPaperAuthorAffiliations AS A
			ON P.PaperId == A.PaperId
			LEFT OUTER JOIN
				@reducedPaperFieldsOfStudy AS F
			ON P.PaperId == F.PaperId
			LEFT OUTER JOIN
				@reducedPaperReferences AS Ref
			ON P.PaperId == Ref.PaperId
			LEFT OUTER JOIN
				@reducedPaperUrls AS Urls
			ON P.PaperId == Urls.PaperId
            
            ORDER BY P.PaperId
			FETCH FIRST 10000 ROWS;

//@affiliationJson =
//	SELECT 
//			(int) (Af.AffiliationId % @Param_PartitionCount) AS PartitionNumber,
//			"{" AS Column001,
//			@JsonAttribute("logprob", @GetLogProbabilityFromRank(Af.Rank)) + "," AS Column002,
//			@JsonAttribute("Id", Af.AffiliationId) + "," AS Column003,
//			@JsonAttribute("DAfN", Af.DisplayName) + "," AS Column004,
//			@JsonAttribute("AfN", Af.NormalizedName) + "," AS Column005,
//			@JsonAttribute("PC", Af.PaperCount) + "," AS Column006,
//			@JsonAttribute("CC", Af.CitationCount) + "," AS Column007,
//			//@JsonAttribute("ECC", AfEcc.EstimatedCitationCount) + "," AS Column008,
//            "" AS Column008,
//			"" AS Column009,
//			"" AS Column010,
//			"" AS Column011,
//			"" AS Column012,
//			"" AS Column013,
//			"" AS Column014,
//			"" AS Column015,
//			"" AS Column016,
//			"" AS Column017,
//			"" AS Column018,
//			"" AS Column019,
//			"" AS Column020,
//			"" AS Column021,
//			"" AS Column022,
//			"" AS Column023,
//			"" AS Column024,
//			"" AS Column025,
//			"" AS Column026,
//			"" AS Column027,
//			"" AS Column028,
//			"" AS Column029,
//			"" AS Column030,
//			"" AS Column031,
//			"" AS Column032,
//			"" AS Column033,
//			"" AS Column034,
//			"" AS Column035,
//			"" AS Column036,
//			"" AS Column037,
//			"" AS Column038,
//			@JsonAttribute("Ty", "5") AS Column039,
//			"}" AS Column040
//	FROM @affiliations AS Af;
////		LEFT OUTER JOIN
////			@affiliationEstimatedCitationCount AS AfEcc
////		ON Af.AffiliationId == AfEcc.AffiliationId;

//@authorJson =
//	SELECT 
//			(int) (Au.AuthorId % @Param_PartitionCount) AS PartitionNumber,
//			"{" AS Column001,
//			@JsonAttribute("logprob", @GetLogProbabilityFromRank(Au.Rank)) + "," AS Column002,
//			@JsonAttribute("Id", Au.AuthorId)+ "," AS Column003,
//			@JsonAttribute("DAuN", Au.DisplayName) + "," AS Column004,
//			@JsonAttribute("AuN", Au.NormalizedName) + "," AS Column005,
//			(Af.AffiliationId == null ? "" : 
//				@JsonRawAttribute("LKA", @JsonObjectFromAttributes(new string[]{
//						@JsonAttribute("AfId", Au.LastKnownAffiliationId), 
//						@JsonAttribute("AfN", Af.NormalizedName)
//				})) + ",") AS Column006,
//			@JsonAttribute("PC", Au.PaperCount) + "," AS Column007,
//			@JsonAttribute("CC", Au.CitationCount) + "," AS Column008,
//			"" AS Column009, //@JsonAttribute("ECC", AuEcc.EstimatedCitationCount == null ? 0 : AuEcc.EstimatedCitationCount) + "," AS Column009,
//			"" AS Column010,
//			"" AS Column011,
//			"" AS Column012,
//			"" AS Column013,
//			"" AS Column014,
//			"" AS Column015,
//			"" AS Column016,
//			"" AS Column017,
//			"" AS Column018,
//			"" AS Column019,
//			"" AS Column020,
//			"" AS Column021,
//			"" AS Column022,
//			"" AS Column023,
//			"" AS Column024,
//			"" AS Column025,
//			"" AS Column026,
//			"" AS Column027,
//			"" AS Column028,
//			"" AS Column029,
//			"" AS Column030,
//			"" AS Column031,
//			"" AS Column032,
//			"" AS Column033,
//			"" AS Column034,
//			"" AS Column035,
//			"" AS Column036,
//			"" AS Column037,
//			"" AS Column038,
//
//			@JsonAttribute("Ty", "1") AS Column039,
//			"}" AS Column040
//	FROM @authors AS Au
//			LEFT OUTER JOIN
//				@affiliations AS Af
//			ON Au._LastKnownAffiliationId == Af.AffiliationId;
////			LEFT OUTER JOIN
////			@authorEstimatedCitationCount AS AuEcc
////			ON  Au.AuthorId == AuEcc.AuthorId;


//@fieldOfStudyJson =
//	SELECT 
//			(int) (Fos.FieldOfStudyId % @Param_PartitionCount) AS PartitionNumber,
//			"{" AS Column001,
//			@JsonAttribute("logprob", @GetLogProbabilityFromRank(Fos.Rank)) + "," AS Column002,
//			@JsonAttribute("Id", Fos.FieldOfStudyId) + "," AS Column003,
//			@JsonAttribute("DFN", Fos.DisplayName) + "," AS Column004,
//			@JsonAttribute("FN", Fos.NormalizedName) + "," AS Column005,           
//			@JsonAttribute("FL", Fos.Level) + "," AS Column006,
//			@JsonAttribute("PC", Fos.PaperCount) + "," AS Column007,
//			@JsonAttribute("CC", Fos.CitationCount) + "," AS Column008, 
//			"" AS Column009, //@JsonAttribute("ECC", FosEcc.EstimatedCitationCount == null ? 0 : FosEcc.EstimatedCitationCount) + "," AS Column009, 
//			(Ch.FieldOfStudyChildren == null? "" : "\"FC\":[" + Ch.FieldOfStudyChildren + "],") AS Column010,
//			(Pr.FieldOfStudyParents == null ? "" :  "\"FP\":[" + Pr.FieldOfStudyParents + "],") AS Column011,
//			"" AS Column012,
//			"" AS Column013,
//			"" AS Column014,
//			"" AS Column015,
//			"" AS Column016,
//			"" AS Column017,
//			"" AS Column018,
//			"" AS Column019,
//			"" AS Column020,
//			"" AS Column021,
//			"" AS Column022,
//			"" AS Column023,
//			"" AS Column024,
//			"" AS Column025,
//			"" AS Column026,
//			"" AS Column027,
//			"" AS Column028,
//			"" AS Column029,
//			"" AS Column030,
//			"" AS Column031,
//			"" AS Column032,
//			"" AS Column033,
//			"" AS Column034,
//			"" AS Column035,
//			"" AS Column036,
//			"" AS Column037,
//			"" AS Column038,
//			@JsonAttribute("Ty", "6") AS Column039,
//			"}" AS Column040
//	FROM @fieldsOfStudy AS Fos
//			LEFT OUTER JOIN
//				@reducedFieldOfStudyChildren AS Ch
//			ON Fos.FieldOfStudyId == Ch.FieldOfStudyId
//			LEFT OUTER JOIN
//			@reducedFieldOfStudyParents AS Pr
//			ON Fos.FieldOfStudyId == Pr.FieldOfStudyId;
////			LEFT OUTER JOIN
////			@fieldOfStudyEstimatedCitationCount AS FosEcc
////			ON Fos.FieldOfStudyId == FosEcc.FieldOfStudyId;

//@journalJson =
//	SELECT 
//			(int) (J.JournalId % @Param_PartitionCount) AS PartitionNumber,
//			"{" AS Column001,
//			@JsonAttribute("logprob", @GetLogProbabilityFromRank(J.Rank)) + "," AS Column002,
//			@JsonAttribute("Id", J.JournalId) + "," AS Column003,
//			@JsonAttribute("DJN", J.DisplayName) + "," AS Column004,
//			@JsonAttribute("JN", J.NormalizedName) + "," AS Column005,
//			@JsonAttribute("PC", J.PaperCount) + "," AS Column006,
//			@JsonAttribute("CC", J.CitationCount) + "," AS Column007,
//			"" AS Column008, //@JsonAttribute("ECC", JEcc.EstimatedCitationCount == null ? 0 : JEcc.EstimatedCitationCount) + "," AS Column008,
//			"" AS Column009,
//			"" AS Column010,
//			"" AS Column011,
//			"" AS Column012,
//			"" AS Column013,
//			"" AS Column014,
//			"" AS Column015,
//			"" AS Column016,
//			"" AS Column017,
//			"" AS Column018,
//			"" AS Column019,
//			"" AS Column020,
//			"" AS Column021,
//			"" AS Column022,
//			"" AS Column023,
//			"" AS Column024,
//			"" AS Column025,
//			"" AS Column026,
//			"" AS Column027,
//			"" AS Column028,
//			"" AS Column029,
//			"" AS Column030,
//			"" AS Column031,
//			"" AS Column032,
//			"" AS Column033,
//			"" AS Column034,
//			"" AS Column035,
//			"" AS Column036,
//			"" AS Column037,
//			"" AS Column038,
//			@JsonAttribute("Ty", "2") AS Column039,
//			"}" AS Column040
//	FROM @journals AS J;
////			LEFT OUTER JOIN
////			@journalEstimatedCitationCount AS JEcc
////			ON J.JournalId == JEcc.JournalId;

@merged =
	SELECT *
	FROM @paperJson;
//	UNION ALL
//	SELECT *
//	FROM @affiliationJson
//	UNION ALL
//	SELECT *
//	FROM @authorJson
//	UNION ALL
//	SELECT *
//	FROM @fieldOfStudyJson
//	UNION ALL
//	SELECT *
//	FROM @journalJson;

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//// Generates partitioned files based on the values in the ForIndexerNumber and PartitionNumber columns
//////////////////////////////////////////////////////////////////////////////////////////////////////////
OUTPUT @merged
TO @outputFilePattern
USING Outputters.Tsv(quoting : false);