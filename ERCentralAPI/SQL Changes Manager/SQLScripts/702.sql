USE [Reviewer]
GO
declare @chk int = (SELECT count(*)
		FROM sys.indexes 
		WHERE name='IX_TB_TRAINING_FS_ITEM_TRAINING_ID_C_ID_CODING_TRAINING_ITEM_ID_RANK' AND object_id = OBJECT_ID('[dbo].[TB_TRAINING_FROM_SEARCH_ITEM]'))
If @chk = 1 
BEGIN
	DROP INDEX [IX_TB_TRAINING_FS_ITEM_TRAINING_ID_C_ID_CODING_TRAINING_ITEM_ID_RANK] ON [dbo].[TB_TRAINING_FROM_SEARCH_ITEM]
END

IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES
           WHERE TABLE_NAME = N'TB_TRAINING_FROM_SEARCH_ITEM')
BEGIN
print 'dropping [dbo].[TB_TRAINING_FROM_SEARCH_ITEM]'
DROP TABLE [dbo].[TB_TRAINING_FROM_SEARCH_ITEM]
END
GO

IF EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES
           WHERE TABLE_NAME = N'TB_TRAINING_FROM_SEARCH')
BEGIN
print 'dropping [dbo].[TB_TRAINING_FROM_SEARCH]'
DROP TABLE [dbo].[TB_TRAINING_FROM_SEARCH]
END
GO

CREATE TABLE [dbo].[TB_TRAINING_FROM_SEARCH](
	[TRAINING_FS_ID] [int] IDENTITY(1,1) NOT NULL,
	[CONTACT_ID] [int] NOT NULL,
	[REVIEW_ID] [int] NOT NULL,
	[DATE] [datetime] NOT NULL,
	[ITERATION] [int] NOT NULL,
	[TRUE_POSITIVES] [int] NULL,
	[TRUE_NEGATIVES] [int] NULL,
 CONSTRAINT [PK_TB_TRAINING_FROM_SEARCH] PRIMARY KEY CLUSTERED 
(
	[TRAINING_FS_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

ALTER TABLE [dbo].[TB_TRAINING_FROM_SEARCH]  WITH CHECK ADD  CONSTRAINT [FK_TB_TRAINING_FROM_SEARCH_TB_CONTACT] FOREIGN KEY([CONTACT_ID])
REFERENCES [dbo].[TB_CONTACT] ([CONTACT_ID])
GO

ALTER TABLE [dbo].[TB_TRAINING_FROM_SEARCH] CHECK CONSTRAINT [FK_TB_TRAINING_FROM_SEARCH_TB_CONTACT]
GO

ALTER TABLE [dbo].[TB_TRAINING_FROM_SEARCH]  WITH CHECK ADD  CONSTRAINT [FK_TB_TRAINING_FROM_SEARCH_TB_REVIEW] FOREIGN KEY([REVIEW_ID])
REFERENCES [dbo].[TB_REVIEW] ([REVIEW_ID])
GO

ALTER TABLE [dbo].[TB_TRAINING_FROM_SEARCH] CHECK CONSTRAINT [FK_TB_TRAINING_FROM_SEARCH_TB_REVIEW]
GO

USE [Reviewer]
GO

/****** Object:  Table [dbo].[TB_TRAINING_ITEM]    Script Date: 29/07/2025 11:08:01 ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE TABLE [dbo].[TB_TRAINING_FROM_SEARCH_ITEM](
	[TRAINING_FS_ITEM_ID] [int] IDENTITY(1,1) NOT NULL,
	[ITEM_ID] [bigint] NULL,
	[RANK] [int] NULL,
	[TRAINING_FS_ID] [int] NULL,
	[CONTACT_ID_CODING] [int] NULL,
	[WHEN_LOCKED] [datetime] NULL,
	[SCORE] [decimal](10, 10) NULL,
 CONSTRAINT [PK_TB_TRAINING_FROM_SEARCH_ITEM] PRIMARY KEY CLUSTERED 
(
	[TRAINING_FS_ITEM_ID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

ALTER TABLE [dbo].[TB_TRAINING_FROM_SEARCH_ITEM]  WITH CHECK ADD  CONSTRAINT [FK_TB_TRAINING_FROM_SEARCH_ITEM_TB_TRAINING_FS] FOREIGN KEY([TRAINING_FS_ID])
REFERENCES [dbo].[TB_TRAINING_FROM_SEARCH] ([TRAINING_FS_ID])
GO

ALTER TABLE [dbo].[TB_TRAINING_FROM_SEARCH_ITEM] CHECK CONSTRAINT [FK_TB_TRAINING_FROM_SEARCH_ITEM_TB_TRAINING_FS]
GO
-----------------------
USE [Reviewer]
GO




/****** Object:  Index [IX_TB_TRAINING_ITEM_TRAINING_ID_C_ID_CODING_TRAINING_ITEM_ID_RANK]    Script Date: 30/07/2025 16:31:00 ******/
CREATE NONCLUSTERED INDEX [IX_TB_TRAINING_FS_ITEM_TRAINING_ID_C_ID_CODING_TRAINING_ITEM_ID_RANK] ON [dbo].[TB_TRAINING_FROM_SEARCH_ITEM]
(
	[TRAINING_FS_ID] ASC,
	[CONTACT_ID_CODING] ASC
)
INCLUDE ( 	[TRAINING_FS_ITEM_ID],
	[RANK]) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO




-----------------------

USE [Reviewer]
GO
/****** Object:  StoredProcedure [dbo].[st_ScreeningCreateMLList]    Script Date: 29/07/2025 11:18:00 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE OR ALTER   procedure [dbo].[st_ScreeningCreate_List_FromSearch]
(
	@REVIEW_ID INT,
	@CONTACT_ID INT,
	@SEARCH_ID BIGINT,
	@CODE_SET_ID INT,
	@NEW_TRAINING_FS_ID int output
)

As

SET NOCOUNT ON
	-- ***** STEP 0 check that we have correct data
	declare @MaxSize int = (SELECT count(*) from TB_SEARCH s
								Inner join TB_SEARCH_ITEM si on s.SEARCH_ID = @SEARCH_ID and s.SEARCH_ID = si.SEARCH_ID and S.IS_CLASSIFIER_RESULT = 1
								AND s.REVIEW_ID = @REVIEW_ID);
	if (@MaxSize < 1 OR @MaxSize is null)
	BEGIN
		set @NEW_TRAINING_FS_ID = -1;
		return;
	END
	declare @IterationN int = 1 + (SELECT MAX(ITERATION) from TB_TRAINING_FROM_SEARCH where REVIEW_ID = @REVIEW_ID);
	if @IterationN is null set @IterationN = 1;

	DECLARE @TP INT
	DECLARE @TN INT

	-- ***** FIRST, GET THE STATS IN TERMS OF # ITEMS SCREENED TO POPULATE THE TRIANING TABLE (GIVES US THE GRAPH ON THE SCREENING TAB)
	SELECT @TP = COUNT(DISTINCT TB_ITEM_ATTRIBUTE.ITEM_ID) FROM TB_ITEM_ATTRIBUTE
		INNER JOIN TB_ATTRIBUTE_SET ON TB_ATTRIBUTE_SET.ATTRIBUTE_ID = TB_ITEM_ATTRIBUTE.ATTRIBUTE_ID AND TB_ATTRIBUTE_SET.ATTRIBUTE_TYPE_ID = 10
		INNER JOIN TB_ITEM_REVIEW ON TB_ITEM_REVIEW.ITEM_ID = TB_ITEM_ATTRIBUTE.ITEM_ID AND TB_ITEM_REVIEW.REVIEW_ID = @REVIEW_ID
		INNER JOIN TB_ITEM_SET ON TB_ITEM_SET.ITEM_SET_ID = TB_ITEM_ATTRIBUTE.ITEM_SET_ID
			AND TB_ITEM_SET.IS_COMPLETED = 'TRUE'
			AND TB_ITEM_SET.SET_ID = @CODE_SET_ID

	SELECT @TN = COUNT(DISTINCT TB_ITEM_ATTRIBUTE.ITEM_ID) FROM TB_ITEM_ATTRIBUTE
		INNER JOIN TB_ATTRIBUTE_SET ON TB_ATTRIBUTE_SET.ATTRIBUTE_ID = TB_ITEM_ATTRIBUTE.ATTRIBUTE_ID AND TB_ATTRIBUTE_SET.ATTRIBUTE_TYPE_ID = 11
		INNER JOIN TB_ITEM_REVIEW ON TB_ITEM_REVIEW.ITEM_ID = TB_ITEM_ATTRIBUTE.ITEM_ID AND TB_ITEM_REVIEW.REVIEW_ID = @REVIEW_ID
		INNER JOIN TB_ITEM_SET ON TB_ITEM_SET.ITEM_SET_ID = TB_ITEM_ATTRIBUTE.ITEM_SET_ID
			AND TB_ITEM_SET.IS_COMPLETED = 'TRUE'
			AND TB_ITEM_SET.SET_ID = @CODE_SET_ID


	-- ********** SECOND, create new line in TB_TRAINING_FROM_SEARCH
	
	INSERT Into TB_TRAINING_FROM_SEARCH ([CONTACT_ID]
           ,[REVIEW_ID]
           ,[DATE]
           ,[ITERATION]
           ,[TRUE_POSITIVES]
           ,[TRUE_NEGATIVES])
     VALUES
           (@CONTACT_ID
           ,@REVIEW_ID
           ,GETDATE()
           ,@IterationN
           ,@TP
           ,@TN)
	set @NEW_TRAINING_FS_ID = SCOPE_IDENTITY();
	-- ********** THIRD, ENTER THE LIST OF ITEMS INTO TB_TRAINING_ITEM ACCORDING TO WHETHER WE'RE FILTERING BY AN ATTRIBUTE OR DOING THE WHOLE REVIEW
	declare @multiplier decimal(10,10);
	declare @MaxRank int = (Select max(ITEM_RANK) from TB_SEARCH_ITEM where SEARCH_ID = @SEARCH_ID)
	if (@MaxRank < 100) set @multiplier = 0.01;
	ELSE if (@MaxRank < 1000) set @multiplier = 0.001;
	ELSE if (@MaxRank < 10000) set @multiplier = 0.0001;
	ELSE if (@MaxRank < 100000) set @multiplier = 0.00001;
	ELSE if (@MaxRank < 1000000) set @multiplier = 0.000001;

	INSERT INTO TB_TRAINING_FROM_SEARCH_ITEM(TRAINING_FS_ID, ITEM_ID, CONTACT_ID_CODING, [RANK], SCORE)
		SELECT @NEW_TRAINING_FS_ID, SI.ITEM_ID, 0, 0, (CAST(SI.ITEM_RANK as decimal (20,10)) * @multiplier)
			FROM TB_SEARCH_ITEM SI
		INNER JOIN TB_ITEM_REVIEW IR ON IR.ITEM_ID = SI.ITEM_ID AND IR.REVIEW_ID = @REVIEW_ID and SI.SEARCH_ID = @SEARCH_ID
		WHERE NOT SI.ITEM_ID IN
			(SELECT ITEM_ID FROM TB_ITEM_SET WHERE IS_COMPLETED = 'TRUE' AND SET_ID = @CODE_SET_ID)
		ORDER BY SI.ITEM_RANK DESC
			
	

	/* SET THE RANKS TO INCREMENT */
	DECLARE @START_INDEX INT = 0
	SELECT @START_INDEX = MIN(TRAINING_FS_ITEM_ID) FROM TB_TRAINING_FROM_SEARCH_ITEM WHERE TRAINING_FS_ID = @NEW_TRAINING_FS_ID
	UPDATE TB_TRAINING_FROM_SEARCH_ITEM
		SET [RANK] = TRAINING_FS_ITEM_ID - @START_INDEX + 1
		WHERE TRAINING_FS_ID = @NEW_TRAINING_FS_ID


	-- FINALLY, MIGRATE ANY NON-STALE CODING LOCKS FROM THE PREVIOUS TRAINING RUN
	DECLARE @LAST_TRAINING_ID INT

	SELECT @LAST_TRAINING_ID = MAX(TRAINING_FS_ID) FROM TB_TRAINING_FROM_SEARCH
		WHERE REVIEW_ID = @REVIEW_ID AND TRAINING_FS_ID < (SELECT MAX(TRAINING_FS_ID) FROM TB_TRAINING_FROM_SEARCH WHERE REVIEW_ID = @REVIEW_ID)

	
	--get locks from previous list of FS type
	UPDATE A
		SET A.CONTACT_ID_CODING = B.CONTACT_ID_CODING,
		A.WHEN_LOCKED = B.WHEN_LOCKED
		FROM TB_TRAINING_FROM_SEARCH_ITEM A
		JOIN
		TB_TRAINING_FROM_SEARCH_ITEM B ON A.ITEM_ID = B.ITEM_ID AND CURRENT_TIMESTAMP < DATEADD(hour, 13, B.WHEN_LOCKED) AND
			B.TRAINING_FS_ID = @LAST_TRAINING_ID
		WHERE A.TRAINING_FS_ID = @NEW_TRAINING_FS_ID

	Declare @lastPStrainingId int = (select MAX(TRAINING_ID) FROM TB_TRAINING
		WHERE REVIEW_ID = @REVIEW_ID AND ITERATION is not null)
	--and again but for locks on the current list of PS type
	UPDATE A
		SET A.CONTACT_ID_CODING = B.CONTACT_ID_CODING,
		A.WHEN_LOCKED = B.WHEN_LOCKED
		FROM TB_TRAINING_FROM_SEARCH_ITEM A
		JOIN
		TB_TRAINING_ITEM B ON A.ITEM_ID = B.ITEM_ID AND CURRENT_TIMESTAMP < DATEADD(hour, 13, B.WHEN_LOCKED) AND
			B.TRAINING_ID = @lastPStrainingId
		WHERE A.TRAINING_FS_ID = @NEW_TRAINING_FS_ID
	

	-- delete the old list(s) of items to screen for this review
	DELETE TI
	FROM TB_TRAINING_FROM_SEARCH_ITEM TI
	INNER JOIN TB_TRAINING_FROM_SEARCH T ON T.TRAINING_FS_ID = TI.TRAINING_FS_ID
	WHERE T.REVIEW_ID = @REVIEW_ID AND T.TRAINING_FS_ID < @NEW_TRAINING_FS_ID

	

SET NOCOUNT OFF
GO

USE [Reviewer]
GO
/****** Object:  StoredProcedure [dbo].[st_ScreeningCreateMLList]    Script Date: 31/07/2025 11:25:20 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
ALTER   procedure [dbo].[st_ScreeningCreateMLList]
(
	@REVIEW_ID INT,
	@CONTACT_ID INT,
	@WHAT_ATTRIBUTE_ID BIGINT,
	@SCREENING_MODE nvarchar(10),
	@CODE_SET_ID INT,
	@TRAINING_ID INT
)

As

SET NOCOUNT ON

	DECLARE @TP INT
	DECLARE @TN INT

	-- ***** FIRST, GET THE STATS IN TERMS OF # ITEMS SCREENED TO POPULATE THE TRIANING TABLE (GIVES US THE GRAPH ON THE SCREENING TAB)
	SELECT @TP = COUNT(DISTINCT TB_ITEM_ATTRIBUTE.ITEM_ID) FROM TB_ITEM_ATTRIBUTE
		INNER JOIN TB_ATTRIBUTE_SET ON TB_ATTRIBUTE_SET.ATTRIBUTE_ID = TB_ITEM_ATTRIBUTE.ATTRIBUTE_ID AND TB_ATTRIBUTE_SET.ATTRIBUTE_TYPE_ID = 10
		INNER JOIN TB_ITEM_REVIEW ON TB_ITEM_REVIEW.ITEM_ID = TB_ITEM_ATTRIBUTE.ITEM_ID AND TB_ITEM_REVIEW.REVIEW_ID = @REVIEW_ID
		INNER JOIN TB_ITEM_SET ON TB_ITEM_SET.ITEM_SET_ID = TB_ITEM_ATTRIBUTE.ITEM_SET_ID
			AND TB_ITEM_SET.IS_COMPLETED = 'TRUE'
			AND TB_ITEM_SET.SET_ID = @CODE_SET_ID

	SELECT @TN = COUNT(DISTINCT TB_ITEM_ATTRIBUTE.ITEM_ID) FROM TB_ITEM_ATTRIBUTE
		INNER JOIN TB_ATTRIBUTE_SET ON TB_ATTRIBUTE_SET.ATTRIBUTE_ID = TB_ITEM_ATTRIBUTE.ATTRIBUTE_ID AND TB_ATTRIBUTE_SET.ATTRIBUTE_TYPE_ID = 11
		INNER JOIN TB_ITEM_REVIEW ON TB_ITEM_REVIEW.ITEM_ID = TB_ITEM_ATTRIBUTE.ITEM_ID AND TB_ITEM_REVIEW.REVIEW_ID = @REVIEW_ID
		INNER JOIN TB_ITEM_SET ON TB_ITEM_SET.ITEM_SET_ID = TB_ITEM_ATTRIBUTE.ITEM_SET_ID
			AND TB_ITEM_SET.IS_COMPLETED = 'TRUE'
			AND TB_ITEM_SET.SET_ID = @CODE_SET_ID

	-- ********** SECOND, ENTER THE LIST OF ITEMS INTO TB_TRAINING_ITEM ACCORDING TO WHETHER WE'RE FILTERING BY AN ATTRIBUTE OR DOING THE WHOLE REVIEW

	IF @WHAT_ATTRIBUTE_ID > 0  -- i.e. we're filtering by a code
	BEGIN
		INSERT INTO TB_TRAINING_ITEM(TRAINING_ID, ITEM_ID, CONTACT_ID_CODING, [RANK], SCORE)
			SELECT @TRAINING_ID, AZ.ITEM_ID, 0, 0, AZ.SCORE
				FROM TB_SCREENING_ML_TEMP AZ
			INNER JOIN TB_ITEM_ATTRIBUTE ON TB_ITEM_ATTRIBUTE.ITEM_ID = AZ.ITEM_ID AND TB_ITEM_ATTRIBUTE.ATTRIBUTE_ID = @WHAT_ATTRIBUTE_ID
			INNER JOIN TB_ITEM_SET ON TB_ITEM_SET.ITEM_SET_ID = TB_ITEM_ATTRIBUTE.ITEM_SET_ID AND TB_ITEM_SET.IS_COMPLETED = 'TRUE'
			INNER JOIN TB_ITEM_REVIEW IR ON IR.ITEM_ID = TB_ITEM_ATTRIBUTE.ITEM_ID AND IR.REVIEW_ID = @REVIEW_ID
			WHERE NOT AZ.ITEM_ID IN
				(SELECT ITEM_ID FROM TB_ITEM_SET WHERE IS_COMPLETED = 'TRUE' AND SET_ID = @CODE_SET_ID) AND AZ.REVIEW_ID = @REVIEW_ID
			ORDER BY AZ.SCORE DESC
			
	END
	ELSE -- NOT FILTERING BY A CODE, SO EVERYTHING IN THE REVIEW THAT'S INCLUDED AND SO FAR UNCODED IS INCLUDED
	BEGIN
		INSERT INTO TB_TRAINING_ITEM(TRAINING_ID, ITEM_ID, CONTACT_ID_CODING, [RANK], SCORE)
		SELECT @TRAINING_ID, AZ.ITEM_ID, 0, 0, AZ.SCORE
				FROM TB_SCREENING_ML_TEMP AZ
			WHERE NOT AZ.ITEM_ID IN
				(SELECT ITEM_ID FROM TB_ITEM_SET WHERE IS_COMPLETED = 'TRUE' AND SET_ID = @CODE_SET_ID) AND AZ.REVIEW_ID = @REVIEW_ID
			ORDER BY AZ.SCORE DESC
	END

	/* SET THE RANKS TO INCREMENT */
	DECLARE @START_INDEX INT = 0
	SELECT @START_INDEX = MIN(TRAINING_ITEM_ID) FROM TB_TRAINING_ITEM WHERE TRAINING_ID = @TRAINING_ID
	UPDATE TB_TRAINING_ITEM
		SET [RANK] = TRAINING_ITEM_ID - @START_INDEX + 1
		WHERE TRAINING_ID = @TRAINING_ID


	-- FINALLY, MIGRATE ANY NON-STALE CODING LOCKS FROM THE PREVIOUS TRAINING RUN
	DECLARE @LAST_TRAINING_ID INT

	SELECT @LAST_TRAINING_ID = MAX(TRAINING_ID) FROM TB_TRAINING
		WHERE REVIEW_ID = @REVIEW_ID AND TRAINING_ID < (SELECT MAX(TRAINING_ID) FROM TB_TRAINING WHERE REVIEW_ID = @REVIEW_ID)

	DECLARE @CURRENT_ITERATION INT
	
	SELECT @CURRENT_ITERATION = MAX(ITERATION) + 1 FROM TB_TRAINING
		WHERE REVIEW_ID = @REVIEW_ID
		
	IF (@CURRENT_ITERATION IS NULL)
	BEGIN
		SET @CURRENT_ITERATION = 1
	END

	--transfer locks from older PS list, into the new one
	UPDATE A
		SET A.CONTACT_ID_CODING = B.CONTACT_ID_CODING,
		A.WHEN_LOCKED = B.WHEN_LOCKED
		FROM TB_TRAINING_ITEM A
		JOIN
		TB_TRAINING_ITEM B ON A.ITEM_ID = B.ITEM_ID AND CURRENT_TIMESTAMP < DATEADD(hour, 13, B.WHEN_LOCKED) AND
			B.TRAINING_ID = @LAST_TRAINING_ID
		WHERE A.TRAINING_ID = @TRAINING_ID

	--then again from current FS list, if any	
	Declare @LAST_TRAINING_FS_ID int = (select MAX(TRAINING_FS_ID) FROM TB_TRAINING_FROM_SEARCH
		WHERE REVIEW_ID = @REVIEW_ID) 
	UPDATE A
		SET A.CONTACT_ID_CODING = B.CONTACT_ID_CODING,
		A.WHEN_LOCKED = B.WHEN_LOCKED
		FROM TB_TRAINING_ITEM A
		JOIN
		TB_TRAINING_FROM_SEARCH_ITEM B ON A.ITEM_ID = B.ITEM_ID AND CURRENT_TIMESTAMP < DATEADD(hour, 13, B.WHEN_LOCKED) AND
			B.TRAINING_FS_ID = @LAST_TRAINING_FS_ID
		WHERE A.TRAINING_ID = @TRAINING_ID


	UPDATE TB_TRAINING
		SET TIME_ENDED = CURRENT_TIMESTAMP,
		ITERATION = @CURRENT_ITERATION,
		TRUE_POSITIVES = @TP,
		TRUE_NEGATIVES = @TN
		WHERE TB_TRAINING.TRAINING_ID = @TRAINING_ID

	-- delete the old list(s) of items to screen for this review
	DELETE TI
	FROM TB_TRAINING_ITEM TI
	INNER JOIN TB_TRAINING T ON T.TRAINING_ID = TI.TRAINING_ID
	WHERE T.REVIEW_ID = @REVIEW_ID AND T.TRAINING_ID < @TRAINING_ID

	DELETE FROM TB_SCREENING_ML_TEMP WHERE REVIEW_ID = @REVIEW_ID

SET NOCOUNT OFF
GO
USE [Reviewer]
GO
/****** Object:  StoredProcedure [dbo].[st_ScreeningCreateNonMLList]    Script Date: 31/07/2025 11:56:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
ALTER procedure [dbo].[st_ScreeningCreateNonMLList]
(
	@REVIEW_ID INT,
	@CONTACT_ID INT,
	@WHAT_ATTRIBUTE_ID BIGINT,
	@SCREENING_MODE nvarchar(10),
	@CODE_SET_ID INT,
	@TRIGGERING_ITEM_ID BIGINT = 0
)

As

SET NOCOUNT ON

	-- ***** PRELIMINARY CHECK (SG Feb 2023): if we received an ITEM_ID val, it's because the training was triggered automatically
	-- in which case we MIGHT not need to rebuild the list, because there is no point in re-shuffling a random list very often
	-- this check can produce 3 effects: 
	-- (1) do nothing (return immediately) when the "triggering item" has already triggered one of the other 2 outcomes
	-- We check for (1) by looking if this item has been coded already by other people, in which case it has (probably) been served by the PS list already
	-- It has been locked to the Other person, and lock has been released when that other person has screened the item.
	-- (2) Create a new record (with updated numbers!) in TB_TRAINING, but without changing the current list. 
	-- This is useful to ensure multiple coding remains efficient: serving the same Items to the required N of reviewers, can't happen if we scramble the items order all the time!
	-- (3) Rebuild the whole list
	DECLARE @shouldRebuild bit = 0
	DECLARE @LAST_TRAINING_ID INT = (select MAX(t.TRAINING_ID) FROM TB_TRAINING t 
									inner join TB_TRAINING_ITEM ti on t.REVIEW_ID = @REVIEW_ID and t.TRAINING_ID = ti.TRAINING_ID
									)
	--Nothing to check if @TRIGGERING_ITEM_ID = 0 as this means somebody ASKED to recreate the list, and thus we should just do that!
	if @TRIGGERING_ITEM_ID = 0 set @shouldRebuild = 1
	ELSE
	BEGIN
		--Check for case (1): is this item ALREADY coded by someone else? If it is, it has been "shown" to that other people already, so it almost certainly has already triggered this SP: we do NOT want
		DECLARE @codedCount int = (select count(ITEM_SET_ID) from tb_item_set where SET_ID = @CODE_SET_ID and ITEM_ID = @TRIGGERING_ITEM_ID and CONTACT_ID != @CONTACT_ID)
		
		-- ***** If this item is coded by someone else: RETURN
		if (@codedCount is not null AND @codedCount > 0) RETURN
	
		--Check for case (2) or (3)
		declare @TotInList int = (select count (TRAINING_ITEM_ID) from TB_TRAINING_ITEM where TRAINING_ID = @LAST_TRAINING_ID)
		declare @highestToDo int = (select RANK from TB_TRAINING_ITEM where ITEM_ID = @TRIGGERING_ITEM_ID and TRAINING_ID = @LAST_TRAINING_ID)
		IF @highestToDo is null --very odd, should not happen, unless we don't have a list to replace!!
				OR (
					@highestToDo >= 1000 -- next item for the current user is 1000 items down the list, enough already!
					OR @highestToDo >= (@TotInList / 2) --we're past half of the list
					)
				--OK we SHOULD rebuild
				set @shouldRebuild = 1
	END

	DECLARE @NEW_TRAINING_ID INT
	DECLARE @TP INT
	DECLARE @TN INT

	-- ***** FIRST, GET THE STATS IN TERMS OF # ITEMS SCREENED TO POPULATE THE TRIANING TABLE (GIVES US THE GRAPH ON THE SCREENING TAB)
	SELECT @TP = COUNT(DISTINCT TB_ITEM_ATTRIBUTE.ITEM_ID) FROM TB_ITEM_ATTRIBUTE
		INNER JOIN TB_ATTRIBUTE_SET ON TB_ATTRIBUTE_SET.ATTRIBUTE_ID = TB_ITEM_ATTRIBUTE.ATTRIBUTE_ID AND TB_ATTRIBUTE_SET.ATTRIBUTE_TYPE_ID = 10
		INNER JOIN TB_ITEM_REVIEW ON TB_ITEM_REVIEW.ITEM_ID = TB_ITEM_ATTRIBUTE.ITEM_ID
		INNER JOIN TB_ITEM_SET ON TB_ITEM_SET.ITEM_SET_ID = TB_ITEM_ATTRIBUTE.ITEM_SET_ID
			AND TB_ITEM_SET.IS_COMPLETED = 'TRUE'
			AND TB_ITEM_SET.SET_ID = @CODE_SET_ID

	SELECT @TN = COUNT(DISTINCT TB_ITEM_ATTRIBUTE.ITEM_ID) FROM TB_ITEM_ATTRIBUTE
		INNER JOIN TB_ATTRIBUTE_SET ON TB_ATTRIBUTE_SET.ATTRIBUTE_ID = TB_ITEM_ATTRIBUTE.ATTRIBUTE_ID AND TB_ATTRIBUTE_SET.ATTRIBUTE_TYPE_ID = 11
		INNER JOIN TB_ITEM_REVIEW ON TB_ITEM_REVIEW.ITEM_ID = TB_ITEM_ATTRIBUTE.ITEM_ID
		INNER JOIN TB_ITEM_SET ON TB_ITEM_SET.ITEM_SET_ID = TB_ITEM_ATTRIBUTE.ITEM_SET_ID
			AND TB_ITEM_SET.IS_COMPLETED = 'TRUE'
			AND TB_ITEM_SET.SET_ID = @CODE_SET_ID


	-- ******** SECOND, ENTER A NEW LINE IN THE TRAINING TABLE ***************
	DECLARE @CURRENT_ITERATION INT
	
	SELECT @CURRENT_ITERATION = MAX(ITERATION) + 1 FROM TB_TRAINING
		WHERE REVIEW_ID = @REVIEW_ID

	IF (@CURRENT_ITERATION IS NULL)
	BEGIN
		SET @CURRENT_ITERATION = 1
	END

	INSERT INTO TB_TRAINING(REVIEW_ID, CONTACT_ID, TIME_STARTED, TIME_ENDED, TRUE_POSITIVES, TRUE_NEGATIVES, ITERATION)
		VALUES (@REVIEW_ID, @CONTACT_ID, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, @TP, @TN, @CURRENT_ITERATION)
	   
	SET @NEW_TRAINING_ID = @@IDENTITY

	-- ********** THIRD, ENTER THE LIST OF ITEMS INTO TB_TRAINING_ITEM ACCORDING TO WHETHER WE'RE FILTERING BY AN ATTRIBUTE OR DOING THE WHOLE REVIEW
	-- ********** NEW [SG Feb 2023] we also check if @shouldRebuild: if so, old code as usual,
	-- ********** OTHERWISE we simply UPDATE the TRAINING_ID in tb_TRAINING_ITEM
	IF @shouldRebuild = 1
	BEGIN
		IF @WHAT_ATTRIBUTE_ID > 0  -- i.e. we're filtering by a code
		BEGIN
			IF @SCREENING_MODE = 'Random' -- FILTERING BY A CODE AND ORDERING AT RANDOM
			BEGIN
				INSERT INTO TB_TRAINING_ITEM(TRAINING_ID, ITEM_ID, CONTACT_ID_CODING, [RANK])
				SELECT @NEW_TRAINING_ID, TB_ITEM_REVIEW.ITEM_ID, 0, 0 FROM TB_ITEM_REVIEW
				INNER JOIN TB_ITEM_ATTRIBUTE ON TB_ITEM_ATTRIBUTE.ITEM_ID = TB_ITEM_REVIEW.ITEM_ID AND TB_ITEM_ATTRIBUTE.ATTRIBUTE_ID = @WHAT_ATTRIBUTE_ID
				INNER JOIN TB_ITEM_SET ON TB_ITEM_SET.ITEM_SET_ID = TB_ITEM_ATTRIBUTE.ITEM_SET_ID AND TB_ITEM_SET.IS_COMPLETED = 'TRUE'
				WHERE REVIEW_ID = @REVIEW_ID AND IS_INCLUDED = 'TRUE' AND IS_DELETED = 'FALSE' AND NOT TB_ITEM_REVIEW.ITEM_ID IN
					(SELECT ITEM_ID FROM TB_ITEM_SET WHERE IS_COMPLETED = 'TRUE' AND SET_ID = @CODE_SET_ID)
				ORDER BY NEWID()
			END
			ELSE -- FILTERING BY A CODE, BUT ORDERING BY THE VALUE PUT IN THE ADDITIONAL_TEXT FIELD
			BEGIN
				INSERT INTO TB_TRAINING_ITEM([RANK], TRAINING_ID, ITEM_ID, CONTACT_ID_CODING)
				SELECT CASE WHEN ISNUMERIC(TB_ITEM_ATTRIBUTE.ADDITIONAL_TEXT)=1 THEN CAST(TB_ITEM_ATTRIBUTE.ADDITIONAL_TEXT AS INT) ELSE 0 END,
					@NEW_TRAINING_ID, TB_ITEM_REVIEW.ITEM_ID, 0
				FROM TB_ITEM_REVIEW
				INNER JOIN TB_ITEM_ATTRIBUTE ON TB_ITEM_ATTRIBUTE.ITEM_ID = TB_ITEM_REVIEW.ITEM_ID AND TB_ITEM_ATTRIBUTE.ATTRIBUTE_ID = @WHAT_ATTRIBUTE_ID
				INNER JOIN TB_ITEM_SET ON TB_ITEM_SET.ITEM_SET_ID = TB_ITEM_ATTRIBUTE.ITEM_SET_ID AND TB_ITEM_SET.IS_COMPLETED = 'TRUE'
				WHERE REVIEW_ID = @REVIEW_ID AND IS_INCLUDED = 'TRUE' AND IS_DELETED = 'FALSE' AND NOT TB_ITEM_REVIEW.ITEM_ID IN
					(SELECT ITEM_ID FROM TB_ITEM_SET WHERE IS_COMPLETED = 'TRUE' AND SET_ID = @CODE_SET_ID)
				ORDER BY TB_ITEM_ATTRIBUTE.ADDITIONAL_TEXT
			END
		END
		ELSE -- NOT FILTERING BY A CODE, SO EVERYTHING IN THE REVIEW THAT'S INCLUDED AND SO FAR UNCODED IS INCLUDED
		BEGIN
			INSERT INTO TB_TRAINING_ITEM(TRAINING_ID, ITEM_ID, CONTACT_ID_CODING, [RANK])
			SELECT @NEW_TRAINING_ID, ITEM_ID, 0, 0 FROM TB_ITEM_REVIEW
				WHERE REVIEW_ID = @REVIEW_ID AND IS_INCLUDED = 'TRUE' AND IS_DELETED = 'FALSE' AND NOT ITEM_ID IN
					(SELECT ITEM_ID FROM TB_ITEM_SET WHERE IS_COMPLETED = 'TRUE' AND SET_ID = @CODE_SET_ID)
				ORDER BY NEWID()
		END
		/* SET THE RANKS TO INCREMENT */
		DECLARE @START_INDEX INT = 0
		SELECT @START_INDEX = MIN(TRAINING_ITEM_ID) FROM TB_TRAINING_ITEM WHERE TRAINING_ID = @NEW_TRAINING_ID
		UPDATE TB_TRAINING_ITEM
			SET [RANK] = TRAINING_ITEM_ID - @START_INDEX + 1
			WHERE TRAINING_ID = @NEW_TRAINING_ID

		-- FINALLY, MIGRATE ANY NON-STALE CODING LOCKS FROM THE PREVIOUS TRAINING RUN
		UPDATE A
			SET A.CONTACT_ID_CODING = B.CONTACT_ID_CODING,
			A.WHEN_LOCKED = B.WHEN_LOCKED
			FROM TB_TRAINING_ITEM A
			JOIN
			TB_TRAINING_ITEM B ON A.ITEM_ID = B.ITEM_ID AND CURRENT_TIMESTAMP < DATEADD(DAY, 7, B.WHEN_LOCKED) AND
				B.TRAINING_ID = @LAST_TRAINING_ID
			WHERE A.TRAINING_ID = @NEW_TRAINING_ID
		
		--then again from current FS list, if any	
		Declare @LAST_TRAINING_FS_ID int = (select MAX(TRAINING_FS_ID) FROM TB_TRAINING_FROM_SEARCH
			WHERE REVIEW_ID = @REVIEW_ID) 
		UPDATE A
			SET A.CONTACT_ID_CODING = B.CONTACT_ID_CODING,
			A.WHEN_LOCKED = B.WHEN_LOCKED
			FROM TB_TRAINING_ITEM A
			JOIN
			TB_TRAINING_FROM_SEARCH_ITEM B ON A.ITEM_ID = B.ITEM_ID AND CURRENT_TIMESTAMP < DATEADD(hour, 13, B.WHEN_LOCKED) AND
				B.TRAINING_FS_ID = @LAST_TRAINING_FS_ID
			WHERE A.TRAINING_ID = @NEW_TRAINING_ID
	

		-- delete the old list(s) of items to screen for this review
		DELETE TI
		FROM TB_TRAINING_ITEM TI
		INNER JOIN TB_TRAINING T ON T.TRAINING_ID = TI.TRAINING_ID
		WHERE T.REVIEW_ID = @REVIEW_ID AND T.TRAINING_ID < @NEW_TRAINING_ID

		END
	ELSE
	BEGIN
		--@shouldRebuild = 0 so we don't scramble the list, just "link" the new TB_TRAINING record to what's already in TB_TRAINING_ITEM
		UPDATE TB_TRAINING_ITEM set TRAINING_ID = @NEW_TRAINING_ID where TRAINING_ID = @LAST_TRAINING_ID
	END

	--got to make sure TIME_ENDED is different from TIME_STARTED!
	UPDATE TB_TRAINING set TIME_ENDED = CURRENT_TIMESTAMP where TRAINING_ID = @NEW_TRAINING_ID

	--UPDATE TB_REVIEW
	--	SET SCREENING_INDEXED = 'TRUE'
	--	WHERE REVIEW_ID = @REVIEW_ID

SET NOCOUNT OFF
GO


USE [Reviewer]
GO
/****** Object:  StoredProcedure [dbo].[st_TrainingNextItem]    Script Date: 29/07/2025 13:24:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
ALTER procedure [dbo].[st_TrainingNextItem]
(
	@REVIEW_ID INT,
	@CONTACT_ID INT,
	@TRAINING_CODE_SET_ID INT,
	@SIMULATE bit = 0,
	@USE_LIST_FROM_SEARCH bit = 0
)

As

SET NOCOUNT ON

	DECLARE @CURRENT_TRAINING_ID INT, @CURRENT_TRAINING_FS_ID int
	Declare @ListedItems TABLE(TRAINING_ITEM_ID int, ITEM_ID bigint, RANK int, CODED_COUNT int null)

	--normal PS queue
	SELECT @CURRENT_TRAINING_ID = MAX(TRAINING_ID) FROM TB_TRAINING
			WHERE REVIEW_ID = @REVIEW_ID
			AND TIME_STARTED < TIME_ENDED
	--queue created from a search
	SELECT @CURRENT_TRAINING_FS_ID = MAX(TRAINING_FS_ID) FROM TB_TRAINING_FROM_SEARCH
			WHERE REVIEW_ID = @REVIEW_ID

	--To start, lets remove ALL stale locks - in two places (2nd place was added July 2025)
	--we need to add/remove locks in both lists always, as if one item is assigned to someone, it has to be assigned to that someone everywhere
	Update TB_TRAINING_ITEM SET CONTACT_ID_CODING = 0, WHEN_LOCKED = NULL
				WHERE TRAINING_ID = @CURRENT_TRAINING_ID AND CONTACT_ID_CODING > 0 and WHEN_LOCKED < DATEADD(hour, -13, GETDATE())
	Update TB_TRAINING_FROM_SEARCH_ITEM SET CONTACT_ID_CODING = 0, WHEN_LOCKED = NULL
				WHERE TRAINING_FS_ID = @CURRENT_TRAINING_FS_ID AND CONTACT_ID_CODING > 0 and WHEN_LOCKED < DATEADD(hour, -13, GETDATE())

	
	-- IF/ELSE ADDED JULY 2025 - depending on what list we're using!!
	IF @USE_LIST_FROM_SEARCH = 0
	BEGIN 
		--GET the ITEM_ID you need to LOCK (for reuse) This isn't straightfoward as it needs to follow the rules implied in the Sreening tab settings!
	
		--insert into table var the items that current user might need to see (excluding the SCREENING_N_PEOPLE setting), that is:
		--those that are not locked by someone else  [AND (ti.CONTACT_ID_CODING = @CONTACT_ID OR ti.CONTACT_ID_CODING = 0)]
		--AND are not [AND tisSel.ITEM_SET_ID is NULL] (already completed OR coded by curr user) [and (tisSel.IS_COMPLETED = 1 OR tisSel.CONTACT_ID = @CONTACT_ID)]
		INSERT into @ListedItems 
			select TRAINING_ITEM_ID , ti.ITEM_ID , RANK , count(tisC.ITEM_SET_ID) as CODED_COUNT FROM
			TB_TRAINING_ITEM ti 
			LEFT OUTER JOIN TB_ITEM_SET tisSel on ti.ITEM_ID = tisSel.ITEM_ID and tisSel.SET_ID = @TRAINING_CODE_SET_ID 
				and (tisSel.IS_COMPLETED = 1 OR tisSel.CONTACT_ID = @CONTACT_ID)
			LEFT OUTER JOIN TB_ITEM_SET tisC on ti.ITEM_ID = tisC.ITEM_ID and tisC.SET_ID = @TRAINING_CODE_SET_ID
			where @CURRENT_TRAINING_ID = ti.TRAINING_ID AND tisSel.ITEM_SET_ID is NULL
			AND (ti.CONTACT_ID_CODING = @CONTACT_ID OR ti.CONTACT_ID_CODING = 0)
			GROUP BY TRAINING_ITEM_ID , ti.ITEM_ID , RANK
		END
	ELSE --added July 2025
	BEGIN
		--GET the ITEM_ID you need to LOCK (for reuse) This isn't straightfoward as it needs to follow the rules implied in the Sreening tab settings!
			
		--insert into table var the items that current user might need to see (excluding the SCREENING_N_PEOPLE setting), that is:
		--those that are not locked by someone else  [AND (ti.CONTACT_ID_CODING = @CONTACT_ID OR ti.CONTACT_ID_CODING = 0)]
		--AND are not [AND tisSel.ITEM_SET_ID is NULL] (already completed OR coded by curr user) [and (tisSel.IS_COMPLETED = 1 OR tisSel.CONTACT_ID = @CONTACT_ID)]
		INSERT into @ListedItems 
			select TRAINING_FS_ITEM_ID , ti.ITEM_ID , RANK , count(tisC.ITEM_SET_ID) as CODED_COUNT FROM
			TB_TRAINING_FROM_SEARCH_ITEM ti 
			LEFT OUTER JOIN TB_ITEM_SET tisSel on ti.ITEM_ID = tisSel.ITEM_ID and tisSel.SET_ID = @TRAINING_CODE_SET_ID 
				and (tisSel.IS_COMPLETED = 1 OR tisSel.CONTACT_ID = @CONTACT_ID)
			LEFT OUTER JOIN TB_ITEM_SET tisC on ti.ITEM_ID = tisC.ITEM_ID and tisC.SET_ID = @TRAINING_CODE_SET_ID
			where @CURRENT_TRAINING_FS_ID = ti.TRAINING_FS_ID AND tisSel.ITEM_SET_ID is NULL
			AND (ti.CONTACT_ID_CODING = @CONTACT_ID OR ti.CONTACT_ID_CODING = 0)
			GROUP BY TRAINING_FS_ITEM_ID , ti.ITEM_ID , RANK
		
	END
--SELECT * from @ListedItems
--SELECT * from @ListedItems where CODED_COUNT < (select SCREENING_N_PEOPLE from TB_REVIEW where REVIEW_ID = @REVIEW_ID)

	--So now we 

	-- NEXT, LOCK THE ITEM WE'RE GOING TO SEND BACK
	DECLARE @sendingBackTID int --this could be a TRAINING_ITEM_ID or TRAINING_FS_ITEM_ID, we need to then change it to an actual ITEM_ID
	DECLARE @maxCoders int = 0 
	SELECT @maxCoders = SCREENING_N_PEOPLE from TB_REVIEW where REVIEW_ID = @REVIEW_ID
	IF @maxCoders = 0 OR @maxCoders is null
	BEGIN --We don't care about SCREENING_N_PEOPLE
		select @sendingBackTID = MIN(TRAINING_ITEM_ID) FROM @ListedItems
	END
	ELSE
	BEGIN --We ignore items already screened by enough people, as per SCREENING_N_PEOPLE
		select @sendingBackTID = MIN(TRAINING_ITEM_ID) FROM @ListedItems where CODED_COUNT < @maxCoders
	END
	--remove ambiguity change @sendingBackTID to contain the actual ITEM_ID
	select @sendingBackTID = ITEM_ID from @ListedItems where TRAINING_ITEM_ID = @sendingBackTID
	
	IF @SIMULATE = 0 AND @sendingBackTID is not null AND @sendingBackTID > 0 --we ARE doing it!
	BEGIN
		--we need to do things twice, for both possible lists
		UPDATE TB_TRAINING_ITEM
			SET CONTACT_ID_CODING = @CONTACT_ID, WHEN_LOCKED = CURRENT_TIMESTAMP
			WHERE
			ITEM_ID = @sendingBackTID and TRAINING_ID = @CURRENT_TRAINING_ID
				
		--[SG July 2025] given that we're locking a new item, we can and SHOULD remove all locks assigned to the current user
		--after all, user can only see one item at the time, so having done the UPDATE above, we now know all pre-existing locks for this user are stale.
		Update TB_TRAINING_ITEM SET CONTACT_ID_CODING = 0, WHEN_LOCKED = NULL
			WHERE TRAINING_ID = @CURRENT_TRAINING_ID AND CONTACT_ID_CODING = @CONTACT_ID and ITEM_ID != @sendingBackTID 
		
		--2nd repeat, for new (July 2025) lists created from searches
		UPDATE TB_TRAINING_FROM_SEARCH_ITEM
			SET CONTACT_ID_CODING = @CONTACT_ID, WHEN_LOCKED = CURRENT_TIMESTAMP
			WHERE
			ITEM_ID = @sendingBackTID and TRAINING_FS_ID = @CURRENT_TRAINING_FS_ID
		
		--as above, make sure this person has only one item locked
		Update TB_TRAINING_FROM_SEARCH_ITEM SET CONTACT_ID_CODING = 0, WHEN_LOCKED = NULL
			WHERE TRAINING_FS_ID = @CURRENT_TRAINING_FS_ID AND CONTACT_ID_CODING = @CONTACT_ID and ITEM_ID != @sendingBackTID 
		
	END
	

-- FINALLY, SEND ITEM BACK
	IF @USE_LIST_FROM_SEARCH = 0
	BEGIN
		SELECT TI.TRAINING_ITEM_ID, ITEM_ID, [RANK], TRAINING_ID, CONTACT_ID_CODING, SCORE
			FROM TB_TRAINING_ITEM TI
			WHERE TI.ITEM_ID = @sendingBackTID and TRAINING_ID = @CURRENT_TRAINING_ID
	end
	ELSE
	BEGIN
		SELECT TI.TRAINING_FS_ITEM_ID as TRAINING_ITEM_ID, ITEM_ID, [RANK], TRAINING_FS_ID as TRAINING_ID, CONTACT_ID_CODING, SCORE
			FROM TB_TRAINING_FROM_SEARCH_ITEM TI
			WHERE TI.ITEM_ID = @sendingBackTID and TRAINING_FS_ID = @CURRENT_TRAINING_FS_ID
	END

SET NOCOUNT OFF
GO


ALTER procedure [dbo].[st_TrainingPreviousItem]
(
	@REVIEW_ID INT,
	@CONTACT_ID INT,
	@ITEM_ID BIGINT,
	@USE_LIST_FROM_SEARCH bit = 0
)

As

SET NOCOUNT ON
	--WE go and fetch a specific training item, making sure we lock it and release any other lock for the same user, if successful
	DECLARE @CURRENT_TRAINING_ID INT, @CURRENT_TRAINING_FS_ID int
	declare @trainingIId int
-- FIRST, GET THE CURRENT TRAINING 'RUN' (CAN'T SEND TO THE STORED PROC, AS IT MAY HAVE CHANGED)
	--normal PS queue
	SELECT @CURRENT_TRAINING_ID = MAX(TRAINING_ID) FROM TB_TRAINING
			WHERE REVIEW_ID = @REVIEW_ID
			AND TIME_STARTED < TIME_ENDED
	--queue created from a search
	SELECT @CURRENT_TRAINING_FS_ID = MAX(TRAINING_FS_ID) FROM TB_TRAINING_FROM_SEARCH
			WHERE REVIEW_ID = @REVIEW_ID

-- NEXT, TRY TO LOCK THE ITEM WE'RE GOING TO SEND BACK (BUT WE WON'T OVERRIDE SOMEONE ELSE'S LOCK)
	--[SG Edit: Feb 2023] we now unlock ALL OTHER items currently locked by the present user
	IF @USE_LIST_FROM_SEARCH = 0
	BEGIN
		 set @trainingIId = (select top 1 TRAINING_ITEM_ID from TB_TRAINING_ITEM 
									where ITEM_ID = @ITEM_ID AND CONTACT_ID_CODING = 0 AND TRAINING_ID = @CURRENT_TRAINING_ID)
		--if @trainingIId is not null and @trainingIId > 0
		--BEGIN
		--	UPDATE TB_TRAINING_ITEM
		--		SET CONTACT_ID_CODING = @CONTACT_ID, WHEN_LOCKED = CURRENT_TIMESTAMP
		--		WHERE TRAINING_ITEM_ID = @trainingIId
		
		--	IF @@ROWCOUNT > 0 set @DoneSomething = 1;
		--END
	END
	ELSE
	BEGIN
		set @trainingIId  = (select top 1 TRAINING_FS_ITEM_ID from TB_TRAINING_FROM_SEARCH_ITEM 
									where ITEM_ID = @ITEM_ID AND CONTACT_ID_CODING = 0 AND TRAINING_FS_ID = @CURRENT_TRAINING_FS_ID)
		--if @trainingFSId is not null and @trainingFSId > 0
		--BEGIN
		--	UPDATE TB_TRAINING_FROM_SEARCH_ITEM
		--		SET CONTACT_ID_CODING = @CONTACT_ID, WHEN_LOCKED = CURRENT_TIMESTAMP
		--		WHERE TRAINING_FS_ITEM_ID = @trainingIId
		
		--	IF @@ROWCOUNT > 0 set @DoneSomething = 1;
		--END
	END


	IF @trainingIId is not null AND @trainingIId > 0
	BEGIN
		--Lock the item in both lists (if it exists)
		UPDATE TB_TRAINING_ITEM
			SET CONTACT_ID_CODING = @CONTACT_ID, WHEN_LOCKED = CURRENT_TIMESTAMP
			WHERE TRAINING_ID = @CURRENT_TRAINING_ID and ITEM_ID = @ITEM_ID
		UPDATE TB_TRAINING_FROM_SEARCH_ITEM
			SET CONTACT_ID_CODING = @CONTACT_ID, WHEN_LOCKED = CURRENT_TIMESTAMP
			WHERE TRAINING_FS_ID = @CURRENT_TRAINING_FS_ID and ITEM_ID = @ITEM_ID

		--We have just locked our ITEM, so we know we can safely unlock all other items currently assigned to this user
		Update TB_TRAINING_ITEM SET CONTACT_ID_CODING = 0, WHEN_LOCKED = NULL
			WHERE CONTACT_ID_CODING = @CONTACT_ID AND TRAINING_ID = @CURRENT_TRAINING_ID and ITEM_ID != @ITEM_ID
		Update TB_TRAINING_FROM_SEARCH_ITEM SET CONTACT_ID_CODING = 0, WHEN_LOCKED = NULL
			WHERE CONTACT_ID_CODING = @CONTACT_ID AND TRAINING_FS_ID = @CURRENT_TRAINING_FS_ID and ITEM_ID != @ITEM_ID
	END
-- FINALLY, SEND IT BACK
	IF @USE_LIST_FROM_SEARCH = 0
	BEGIN
		SELECT TI.TRAINING_ITEM_ID, ITEM_ID, [RANK], TRAINING_ID, @CONTACT_ID, SCORE
			FROM TB_TRAINING_ITEM TI
			WHERE TRAINING_ID = @CURRENT_TRAINING_ID AND ITEM_ID = @ITEM_ID
	END
	ELSE
	BEGIN
		SELECT TI.TRAINING_FS_ITEM_ID as TRAINING_ITEM_ID, ITEM_ID, [RANK], TRAINING_FS_ID as TRAINING_ID, CONTACT_ID_CODING, SCORE
			FROM TB_TRAINING_FROM_SEARCH_ITEM TI
			WHERE TRAINING_FS_ID = @CURRENT_TRAINING_FS_ID and TI.ITEM_ID = @ITEM_ID 
	END
SET NOCOUNT OFF
GO

USE [Reviewer]
GO
/****** Object:  StoredProcedure [dbo].[st_ItemAttributeAutoReconcile]    Script Date: 30/07/2025 16:28:57 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
ALTER procedure [dbo].[st_ItemAttributeAutoReconcile]
(
	@ITEM_ID BIGINT,
	@SET_ID INT,
	@ATTRIBUTE_ID BIGINT,
	@RECONCILLIATION_TYPE nvarchar(10),
	@N_PEOPLE int,
	@AUTO_EXCLUDE bit,
	@CONTACT_ID int
)

As
SET NOCOUNT ON

DECLARE @COUNT_RECS INT = 0
DECLARE @ITEM_SET_ID INT = 0

IF (@RECONCILLIATION_TYPE != 'no compl') --i.e. we may need to do something, not just unlock the item
BEGIN
	-- **************** STAGE 1: GATHER DATA ON WHETHER RULES FOR AUTO-RECONCILLIATION ARE MET ********************

	IF (@RECONCILLIATION_TYPE = 'Single')
	BEGIN
		SET @COUNT_RECS = 99 -- i.e. we go through to automatic exclude check

		SELECT TOP(1) @ITEM_SET_ID = ITEM_SET_ID FROM TB_ITEM_SET
			WHERE ITEM_ID = @ITEM_ID AND SET_ID = @SET_ID
	END
	
	IF (@RECONCILLIATION_TYPE = 'auto code') -- agreement at the code level
	BEGIN
		SELECT @COUNT_RECS = COUNT(*) FROM TB_ITEM_ATTRIBUTE
			WHERE ITEM_ID = @ITEM_ID AND ATTRIBUTE_ID = @ATTRIBUTE_ID
		IF (@COUNT_RECS >= @N_PEOPLE)
		BEGIN
			SELECT TOP(1) @ITEM_SET_ID = TB_ITEM_SET.ITEM_SET_ID FROM TB_ITEM_SET
				INNER JOIN TB_ITEM_ATTRIBUTE ON TB_ITEM_ATTRIBUTE.ITEM_SET_ID = TB_ITEM_SET.ITEM_SET_ID
				WHERE TB_ITEM_SET.ITEM_ID = @ITEM_ID AND SET_ID = @SET_ID AND CONTACT_ID = @CONTACT_ID
		END
		ELSE
		BEGIN
			SET @ITEM_SET_ID = 0
		END
	END

	-- one person has to tick 'include' for it to be included.-- N people agreeing on exclude if nobody has ticked 'include' before this threshold is met
	IF (@RECONCILLIATION_TYPE = 'auto safet') 
	BEGIN
		SELECT @COUNT_RECS = COUNT(*) FROM TB_ITEM_ATTRIBUTE IA
			INNER JOIN TB_ITEM_SET ISE ON ISE.ITEM_SET_ID = IA.ITEM_SET_ID
			INNER JOIN TB_ATTRIBUTE_SET AST ON AST.ATTRIBUTE_ID = IA.ATTRIBUTE_ID
			WHERE IA.ITEM_ID = @ITEM_ID AND ISE.SET_ID = @SET_ID AND AST.ATTRIBUTE_TYPE_ID = 10 -- is anything included?

		SELECT TOP(1) @ITEM_SET_ID = ISE.ITEM_SET_ID FROM TB_ITEM_ATTRIBUTE IA
			INNER JOIN TB_ITEM_SET ISE ON ISE.ITEM_SET_ID = IA.ITEM_SET_ID
			INNER JOIN TB_ATTRIBUTE_SET AST ON AST.ATTRIBUTE_ID = IA.ATTRIBUTE_ID
			WHERE IA.ITEM_ID = @ITEM_ID AND ISE.SET_ID = @SET_ID AND AST.ATTRIBUTE_TYPE_ID = 10 AND CONTACT_ID = @CONTACT_ID
		IF (@COUNT_RECS > 0)
		BEGIN
			SET @COUNT_RECS = @N_PEOPLE
		END
		ELSE
		BEGIN
			-- IF NO INCLUDE IS TICKED, HAVE N PEOPLE TICKED EXCLUDE? IF SO, WE DEFAULT TO THIS
			SELECT @COUNT_RECS = COUNT(*) FROM TB_ITEM_ATTRIBUTE IA
				INNER JOIN TB_ITEM_SET ISE ON ISE.ITEM_SET_ID = IA.ITEM_SET_ID
				INNER JOIN TB_ATTRIBUTE_SET AST ON AST.ATTRIBUTE_ID = IA.ATTRIBUTE_ID
				WHERE IA.ITEM_ID = @ITEM_ID AND ISE.SET_ID = @SET_ID AND AST.ATTRIBUTE_TYPE_ID = 11 -- EXCLUDED
			SELECT TOP(1) @ITEM_SET_ID = ISE.ITEM_SET_ID FROM TB_ITEM_ATTRIBUTE IA
				INNER JOIN TB_ITEM_SET ISE ON ISE.ITEM_SET_ID = IA.ITEM_SET_ID
				INNER JOIN TB_ATTRIBUTE_SET AST ON AST.ATTRIBUTE_ID = IA.ATTRIBUTE_ID
				WHERE IA.ITEM_ID = @ITEM_ID AND ISE.SET_ID = @SET_ID AND AST.ATTRIBUTE_TYPE_ID = 11  AND CONTACT_ID = @CONTACT_ID
		END
		IF (@COUNT_RECS < @N_PEOPLE)
		BEGIN
			SET @ITEM_SET_ID = 0
		END
	END
	
	 -- agreement at the include / exclude level
	IF (@RECONCILLIATION_TYPE = 'auto excl')
	BEGIN
		SELECT @COUNT_RECS = COUNT(*) FROM TB_ITEM_ATTRIBUTE IA
			INNER JOIN TB_ITEM_SET ISE ON ISE.ITEM_SET_ID = IA.ITEM_SET_ID
			INNER JOIN TB_ATTRIBUTE_SET AST ON AST.ATTRIBUTE_ID = IA.ATTRIBUTE_ID
			WHERE IA.ITEM_ID = @ITEM_ID AND ISE.SET_ID = @SET_ID AND AST.ATTRIBUTE_TYPE_ID = 10 -- INCLUDED
		SELECT TOP(1) @ITEM_SET_ID = ISE.ITEM_SET_ID FROM TB_ITEM_ATTRIBUTE IA
			INNER JOIN TB_ITEM_SET ISE ON ISE.ITEM_SET_ID = IA.ITEM_SET_ID
			INNER JOIN TB_ATTRIBUTE_SET AST ON AST.ATTRIBUTE_ID = IA.ATTRIBUTE_ID
			WHERE IA.ITEM_ID = @ITEM_ID AND ISE.SET_ID = @SET_ID AND AST.ATTRIBUTE_TYPE_ID = 10  AND CONTACT_ID = @CONTACT_ID

		IF (@COUNT_RECS < @N_PEOPLE)
		BEGIN
			SELECT @COUNT_RECS = COUNT(*) FROM TB_ITEM_ATTRIBUTE IA
				INNER JOIN TB_ITEM_SET ISE ON ISE.ITEM_SET_ID = IA.ITEM_SET_ID
				INNER JOIN TB_ATTRIBUTE_SET AST ON AST.ATTRIBUTE_ID = IA.ATTRIBUTE_ID
				WHERE IA.ITEM_ID = @ITEM_ID AND ISE.SET_ID = @SET_ID AND AST.ATTRIBUTE_TYPE_ID = 11 -- EXCLUDED
			SELECT TOP(1) @ITEM_SET_ID = ISE.ITEM_SET_ID FROM TB_ITEM_ATTRIBUTE IA
				INNER JOIN TB_ITEM_SET ISE ON ISE.ITEM_SET_ID = IA.ITEM_SET_ID
				INNER JOIN TB_ATTRIBUTE_SET AST ON AST.ATTRIBUTE_ID = IA.ATTRIBUTE_ID
				WHERE IA.ITEM_ID = @ITEM_ID AND ISE.SET_ID = @SET_ID AND AST.ATTRIBUTE_TYPE_ID = 11  AND CONTACT_ID = @CONTACT_ID
		END
	END

	

	-- *************************** STAGE 2: AUTO-RECONCILE AND AUTO-COMPLETE ***************************

	IF (@COUNT_RECS >= @N_PEOPLE) AND (@RECONCILLIATION_TYPE != 'Single') -- AUTO-RECONCILE (COMPLETE) WHERE RULES MET
	BEGIN
		DECLARE @CHECK_NONE_COMPLETED INT = 
			(SELECT COUNT(ITEM_SET_ID) FROM TB_ITEM_SET WHERE ITEM_ID = @ITEM_ID AND SET_ID = @SET_ID AND IS_COMPLETED = 'TRUE')

		IF (@CHECK_NONE_COMPLETED = 0)
		BEGIN
			UPDATE TB_ITEM_SET
				SET IS_COMPLETED = 'TRUE'
				WHERE ITEM_SET_ID = @ITEM_SET_ID
		END
	END
	
	IF (@AUTO_EXCLUDE = 'TRUE' AND @ITEM_SET_ID > 0 and @COUNT_RECS >= @N_PEOPLE) -- AUTO EXCLUDE WHERE RULES MET
	BEGIN
		-- SECOND, AUTO INCLUDE / EXCLUDE
		DECLARE @IS_INCLUDED BIT = 'TRUE'
		SELECT TOP(1) @IS_INCLUDED = CASE WHEN ATTRIBUTE_TYPE_ID = 11 THEN 'FALSE' ELSE 'TRUE' END
			FROM TB_ATTRIBUTE_SET
				INNER JOIN TB_ITEM_ATTRIBUTE ON TB_ITEM_ATTRIBUTE.ATTRIBUTE_ID = TB_ATTRIBUTE_SET.ATTRIBUTE_ID
				WHERE ITEM_SET_ID = @ITEM_SET_ID
		UPDATE TB_ITEM_REVIEW
			SET IS_INCLUDED = @IS_INCLUDED
			WHERE ITEM_ID = @ITEM_ID
	END
END

--finally unlock this item away from this person, as they have coded it. Do so on both lists (if present)
UPDATE TB_TRAINING_ITEM
	SET CONTACT_ID_CODING = 0, WHEN_LOCKED = NULL
	WHERE CONTACT_ID_CODING = @CONTACT_ID AND ITEM_ID = @ITEM_ID
UPDATE TB_TRAINING_FROM_SEARCH_ITEM
	SET CONTACT_ID_CODING = 0, WHEN_LOCKED = NULL
	WHERE CONTACT_ID_CODING = @CONTACT_ID AND ITEM_ID = @ITEM_ID

SET NOCOUNT OFF
GO