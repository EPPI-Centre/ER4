# ER-Web Readme
This file is intended to provide a general description of how EPPI Reviewer 6 (ER6) works. And in particular, how things "stick together", with special emphasis on the changes made when moving from Angular 7 (?) to Angular v.13, and from DotNet Core 2.x to DotNet6.

Please see the **recommended settings** section at the bottom!

## Overview (theory first! How to is below...)
ER6 is now divided in two, almost entirely independed visual studio projects: `ER-Web-API` and `ER-Web-Client`. Both are derived from standard MS templates: "ASP.NET Core Web API" and "Standalone TypeScript Angular project".

Importantly, the latter did not use the "Add integration for Empty ASP.NET Web API Project" option, which means:
1. It does not use the Angular client-side proxy to route API calls from client to server side (would be used in development phase only).
1. The project is closer to a vanilla Angular app in some ways (no additional, pre configured proxy).
1. It includes one special (ad-hoc) provision to allow specifying "where" the API endpoints are to be found.

### What about the (missing) proxy?
When implementing an Angular App + separate API, in development, both projects are likely to run as DotNet "command line" apps or within IIS-Express. In both cases, they both function from separate executables, and as "web apps", which need to respond to HTTP(S) requests. Given this need, each has to "listen" to a separate port. This produces a problem: if Client App uses `localhost:1234` and API has `localhost:4321` as their base URL, the browser and API will both "block" Javascript-triggered http requests generated by the client and directed to the API. This is because of CORS (https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS). Thus, in a development setting, it becomes complicated to allow "talking to the API".

This is what the "proxy" is for. It can be configured to "intercept" some requests (based on their path), which are generated by the client (and thus addressed to `localhost:1234`, the client route) and re-route them to the API base url (`localhost:4321` in our example). 

I did not like this "solution" because it generates a problem that happens _only_ in development: we need to ensure the proxy can reliably distinguish between https requests that should be re-routed/proxied and those who should not. While experimenting, I got "caught" in several situations where this wasn't easy, so in exasperation, I tried to find a _better_ way. Not sure I did find something better, as I had to tackle CORS head-on, which ain't simple!

### Managing CORS
This is done in two blocks inside `program.cs`. The first block retrieves the URL used by the client app and generates the necessary "CORS permissions", the second blocks ensures the API uses the "CORS" middleware, to apply said permissions to the whole project.

Naturally, enabling CORS is a security risk, therefore both blocks are wrapped in `#if DEBUG ... #endif` compiler directives, ensuring that _production code_ (compiled in the "Release" configuration) will not even contain the risky code. Moreover, we use the `appsettings.Development.json` file to hold the `clientURL` value (not the "regular" `appsettings.json` file) - full address of the value is: `["AppSettings:clientURL"]`. 

The code will not configure CORS permissions if there is no `clientURL` value; thus, we have two mechanisms in place, each sufficient to prevent CORS from being enabled in production.

### How does the client "know" where is the API?
The way to let the API base url known to the client is inspired by this page:
https://davembush.github.io/where-to-store-angular-configurations/

Specifically, the `\src\assets\APIUrl.txt` contains the following:
```
{
  "APIBaseUrl": "https://localhost:44344"
}
```
the Value it carries is then read "on startup" by the client (actually done via a GET request) and then placed in the `ConfigService` component, which is then injected into most/all services (and the "home" component). Thus, every bit of ER-Web (Client) which needs to "talk" to the API will use the value included in this file as the baseUrl for the API.

> [Aside: this system allows us to configure the client on the fly, without a publish, and could be used to store and react to more values in the future, for example to "enable" features without a publish]

Importantly, the system that does this will fallback to `https://eppi.ioe.ac.uk/ER-Web-API/` as the base API url, in case we'll forget to put the APIUrl.txt file in place. Moreover, this file is of ".txt" type, so that we don't need to allow our production server to serve .json files, which could create security risks.

## Making the two projects "talk" (summary)
Overall, in production, the Client project needs to "be told" where the API is. In dev environments, both projects now need to "be told" where the other project sits. 

- **To instruct the client:** place the API URL in `\src\assets\APIUrl.txt` 

- **To instruct the API:** place the client URL in `appsettings.Development.json`.

Editing one or the other file _might_ be necessary when publishing (`APIUrl.txt` only), and/or when for whichever reason, the port of one or the other project is changed "In dev".

## Before you start: checking project/solution settings
This is useful to ensure the two projects both run on the expected url/protocol/ports, so that you _won't need_ to change the two files mentioned above.

To start with, from the "debug/play" dropdown below the VS menus, **pick `ER-Web-API` as the startup project** (for now), and expand the options in the "play" dropdown menu. You want to select `IIS express` as this is likely to be already setup to make the project run on the expected port.

Then, you want to right click the `ER-Web-API` project from the "Solution explorer" column, and pick properties. Go to the "Debug" section, which will contain an "Open debug launch profiles" link. Click it and you'll find an option to "launch the browser", which you want to leave **unticked**. Then, at the bottom, you want to find the option that says "Use SSL" followed by the url that will be used (showing the "port" to which it will respond). If that URL is _not_ "https://localhost:44344" (and you can't set it to this value), then you'll need to edit the "APIUrl.txt" file.


### Client APP: what you need to know
It's a vanilla Angular App, which you can start from the command line "npm start", or from VS itself. It won't work if the corresponding API isn't "listening" (running), though. The Angular CLI ("ng [command] ...") if fully functional, which _should_ make upgrading, and the creation of Angular Unit Tests easier, from now on. [If you're trying to run ER6 for the first time, see the [Readme file](ER-Web-Client/ER6-Client-README.md) for the Client project, where dependecies are discussed.]

On the other hand, adding npm packages, although it _should_ work reliably (Either: `ng add [package]` or `npm --install --save [package]`), is really fragile. Given the number of packages we have installed, sometimes things go wrong and produce thousands of compiler errors, which are difficult to parse as they happen on the console terminal, instead of VS errors list.

Moreover, when developing ER6 in the standard/recommended way, the Angular CLI "npm start" command line window **does not close automatically** when one stops debugging. So, if you stopped debugging _because_ you wanted the Angular App to restart (for whatever reason), **you have to remember** to close the CLI command window manually.

The client project is configured to use the "Hot Module Replacement" system which is now part of Angular core facilities. At the time of writing, I'm still not sure why sometimes some components fail to get a "hot update", which means that pressing "F5" to get a full refresh is sometimes useful (or stop debugging, closing the CLI `ng start` window, and starting to debug again, which is slow as building the whole Angular client takes 1-2 minutes!).


### API: what you need to know
Hard to say! The project is configured to use https:// so hopefully at the first run, VS will ask if you want to use a self-signed certificate for this, to which **you should** answer YES. You also want to check that it's listening to port 44344, OR change the `\src\assets\APIUrl.txt` in the client to match the port you're using (which will cascade problems to _other_ developers, though).

# How to: recommended settings
In most cases, you will want to click "debug(play)" once, get both projects started and then rely on hot-module-replacement to keep the angular side up-to-date. For this you can use the `Debug\Set startup project` dialog (from the VS menus).

You would pick "multiple startup projects", and have both client and api projects set with "start", making sure the API proj appears first.

If/when you'll need to _restart_ the API (to apply changes) restarting the whole app _will not_ rebuild the client (if you didn't close the corresponding Angular CLI command window explictily), which makes such restarts faster. Moreover, if you opened up a _separate_ browser window and used that to interact with the client (not the window opened by VS!), clicking "restart" won't close it, which makes the whole process painless.

The downside is that when you click "Stop" the Angular CLI process that "serves" the angular app does not shut down (the command window remains!), so when you need to actually stop/restart the Angular app entirely (for example, if you want to install new npm packages) **you have to remember** to close the command window manually!

To be entirely "free" to change both ends and have minimal delays, you can also start the angular project from the command line, and the API project from VS. You then need to manually browse to `http://localhost:4200/` (to open the client) but at this point, changing things on the API project and clicking "restart" will _only_ restart the API project, wich will be fast. 

For the Angular side, unless you need to add new modules or npm packages, the "Hot Module Replacement" mechanism works most of the times, allowing to update the client automatically when you save a file change. As "hot updates" accumulate, this system does appear to get slower, so sometimes restarting the Angular CLI `ng start` command line is useful, even if it takes 1-2m to complete.


## Cochrane authentication instructions

The purpose of this set of instructions is to illustrate the configuration changes which allow to run the Angular client while using a specific URL, known to Cochrane, as (see below) the `Callback URL` needs to be exact and known to both parties, it also needs to be of the `https` kind, making things annoyingly difficult.

This is complex, as there are a number of requirements to fulfil.

First and foremost, only known 3rd parties are authorised to plug in the Cochrane oAuth system, which means that the dev environment needs to impersonate ssru38.ioe.ac.uk in the eyes of the Cochrane counterpart, so to be seen as an "authorised client".

Thus, you need to do a number of changes, in order to make this impersonation thing happen. You may need a (self signed) certificate for `ssru38.ioe.ac.uk` and to make it available to the Angular (dev) server. How this is done it's unclear to me, as I've done too many trial and error attempts, making it hard to figure what actually works.

You also need to add this line to the `C:\Windows\System32\drivers\etc\hosts` file:
`127.0.0.1  ssru38.ioe.ac.uk`. This tells Windows that `ssru38.ioe.ac.uk` has the "localhost" IP address...

Then, you need to tell the Angular (dev) webserver to serve the angular app over https, which is done in `[...]\ERCentralAPI\ER-Web-Client\package.json` via this line:
`"start": "ng serve --hmr ",` becomes `"ng serve --hmr --host ssru38.ioe.ac.uk --ssl",`, I reckon that what this does is quite self-explanatory (`ng serve` on its own will serve `localhost:4200`, we change the hostname and ask to use ssl too). [**This change is NOT integrated in the regular code-base.**]

We also need to tell VS what browser and URL to open when launching the Client project, which is done by editing this file `[...]\ERCentralAPI\ER-Web-Client\.vscode\launch.json`, adding one element like this:

```
    {
      "type": "chrome",
      "request": "launch",
      "name": "SSRU38 (Chrome)",
      "url": "https://ssru38.ioe.ac.uk:4200",
      "webRoot": "${workspaceFolder}"
    },
```

This creates a new "startup" submenu entry for `Configure Startup Project` dialog in VS, which now has the new option `SSRU38 (Chrome)` - you'll need to pick this one for things to work nicely with Cochrane authentication in dev. [**This change** (meaning the entry in `launch.json`) **is integrated in the regular code-base.**]

However, serving the non-default URL breaks the Cross-origin resource sharing (CORS) permissions in the API project (when running in dev conditions), so we need to change `[...]\ERCentralAPI\ER-Web\appsettings.Development.json`, editing the line `"clientURL": "http://localhost:4200"` to `"clientURL": "https://ssru38.ioe.ac.uk:4200"` - this tells the API project that it's OK to respond to requests originating from "https://ssru38.ioe.ac.uk:4200" even if the API sits on a separate DNS address (`https://localhost:44344`).[**This change is NOT integrated in the regular code-base.**]


We then need to tell the ER6 API what the "known to both parties" **callback URL** is, we do this by editing `appsettings.json`, changing this line `"CochraneOAuthRedirectUri": "https://ssru38.ioe.ac.uk/ERx/ArchieCallBack"` to `"CochraneOAuthRedirectUri": "https://ssru38.ioe.ac.uk:4200/ArchieCallBack"`.[**This change is integrated in the regular code-base.** And of course, appsettings.json is different **in production**.]

Importantly, the "callback" URL needs to be known and authorised on the Cochrane end (and is case sensitive!). At the time of writing, the following urls are authorised in the Cochrane TEST environment:

- `https://ssru38.ioe.ac.uk/WcfHostPortal/ArchieCallBack.aspx` this one is used by ER4 in dev. 
- `https://eppi.ioe.ac.uk/eppireviewer4/ArchieCallBack.aspx` is the live/production one for ER4, and I'm not sure why it's present here.
- `https://ssru38.ioe.ac.uk/ERx/ArchieCallBack` is what we used before "separating" Angular and API projects. Might be useful sometime in the future.
- `https://ssru38.ioe.ac.uk:4200/ArchieCallBack` is the present one for ER6 in dev.

## Summary of Config changes to make to make oAuth with Cochrane work:
1. change "launch" profile for the **Client** so to make it start the `SSRU38 (chrome)` debug target.
1. In `[API root]\appsettings.Development.json` change the `clientURL` to `https://ssru38.ioe.ac.uk:4200`.
1. in `\ER-Web-Client\package.json` change the `start` value to `ng serve --hmr --host ssru38.ioe.ac.uk --ssl`
1. [Optional] if you need to change the target environment (from `test-` to `training-`):
    1. Change `Appsettings.json` values for: `CochraneoAuthBaseAddress`, `CochraneAPIBaseAddress`
    1. Change `appsettings.Development.json` value for: `CochraneOAuthSS`
    1. In the client, change `revieweridentity.service.ts`. In the `GoToArchie()` method, the hardoced URL for the test environment needs to be updated.
1. [If necessary] get a fresh start, including:
    1. Stop debugging
    1. Close the `ng serve` Command window, as it's likely serving the wrong URL (`http://localhost:4200` instead of `https://ssru38.ioe.ac.uk:4200`)
    1. Start debugging

Upon finishing the work, make sure you do not commit changes files that would break other dev environment and ensure ER will run normally:

- `package.json` - this needs to go back to the old value of `ng serve --hmr`
- Pick the regular debug environment for the client startup properties
- Possibly undo changes to `appsettings.json` (and `appsettings.developer.json`, which Git ignores anyway!). No secret should be in the former, regular values for the normal test environemnt should be left in both files.
- Check changes in `revieweridentity.service.ts` so to ensure it points to `https://test-login.cochrane.org`


