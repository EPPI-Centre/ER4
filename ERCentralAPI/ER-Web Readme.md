# ER-Web Readme
This file is intended to provide a general description of how things "stick together", with special emphasis on the changes made when moving from Angular 7 (?) to Angular v.13, and from DotNet Core 2.x to DotNet6.

Please see the **recommended settings** section at the bottom!

## Overview (theory first! How to is below...)
EPPI-Reviewer Web is now divided in two, almost entirely independed visual studio project: `ER-Web-API` and `ER-Web-Client`. Both are derived from standard MS templates: "ASP.NET Core Web API" and "Standalone TypeScript Angular project".

Importantly, the latter did not use the "Add integration for Empty ASP.NET Web API Project" option, which means:
1. It does not use the Angular client-side proxy to route API calls from client to server side (used in development phase only).
1. The project is closer to a vanilla Angular app in some ways (no additional, pre configured proxy).
1. It includes one special provision to allow specifying "where" the API endpoints are to be found.

### What about the (missing) proxy?
When implementing an Angular App + separate API, in development, both projects are likely to run as DotNet "command line" apps or within IIS-Express. In both cases, they both function from separate executables, and as "web apps", which need to respond to HTTP(S) requests. Given this need, each has to "listen" to a separate port. This produces a problem: if Client App uses `localhost:1234` and API has `localhost:4321` as their base URL, the browser and API will both "block" Javascript-triggered http requests generated by the client and directed to the API. This is because of CORS (https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS). Thus, in a development setting, it becomes complicated to allow "talking to the API".

This is what the "proxy" is for. It can be configured to "intercept" some requests (based on their path), which are generated by the client (and thus addressed to `localhost:1234`, the client route) and re-route them to the API base url (`localhost:4321` in our example). 

I did not like this "solution" because it generates a problem that happens _only_ in development: we need to ensure the proxy can reliably distinguish between https requests that should be re-routed/proxied and those who should not. While experimenting, I got "caught" in several situations where this wasn't easy, so in exasperation, I tried to find a _better_ way. Not sure I did find something better, as I had to tackle CORS head-on, which ain't simple!

### Managing CORS
This is done in two blocks inside `program.cs`. The first block retrieves the URL used by the client app and generates the necessary "CORS permissions", the second blocks ensures the API uses the "CORS" middleware, to apply said permissions to the whole project.

Naturally, enabling CORS is a security risk, therefore both blocks are wrapped in `#if DEBUG ... #endif` compiler directives, ensuring that _production code_ will not even contain the risky code. Moreover, we use the `appsettings.Development.json` file to hold the `clientURL` value (not the "regular" `appsettings.json` file) - full address of the value is: `["AppSettings:clientURL"]`. 

The code will not configure CORS permissions if there is no `clientURL` value; thus, we have two mechanisms in place, each sufficient to prevent CORS from being enabled in production.

### How does the client "know" where is the API?
The way to let the API base url known to the client is inspired by this page:
https://davembush.github.io/where-to-store-angular-configurations/

Specifically, the `\src\assets\APIUrl.txt` contains the following:
```
{
  "APIBaseUrl": "https://localhost:44344"
}
```
the Value it carries is then read "on startup" by the client (actually done via a GET request) and then placed in the `ConfigService` component, which is then injected into most/all services (and the "home" component). Thus, every bit of ER-Web (Client) which needs to "talk" to the API will use the value included in this file as the baseUrl for API.

> [Aside: this system allows us to configure the client on the fly, without a publish, and could be used to store and react to more values in the future, for example to "enable" features without a publish]

Importantly, the system that does this will fallback to `https://eppi.ioe.ac.uk/ER-Web-API/` as the base API url, in case we'll forget to put the APIUrl.txt file in place. Moreover, this file is of ".txt" type, so that we don't need to allow our production server to serve .json files, which could create security risks.

## Making the two projects "talk" (summary)
Overall, in production, the Client project needs to "be told" where the API is. In dev environments, both projects now need to "be told" where the other project sits. 

- **To instruct the client:** place the API URL in `\src\assets\APIUrl.txt` 

- **To instruct the API:** place the client URL in `appsettings.Development.json`.

Editing one or the other file _might_ be necessary when publishing (the former file!), and/or when for whichever reason, the port of one or the other project is changed "In dev".

## Before you start: checking project/solution settings
This is useful to ensure the two projects both run on the expected url/protocol/ports, so that you _won't need_ to change the two files mentioned above.

To start with, from the "debug/play" dropdown below the VS menus, pick `ER-Web-API` as the startup project (for now), and expand the options in the "play" dropdown menu. You want to select `IIS express` as this is likely to be already setup to make the project run on the expected port.

Then, you want to right click the `ER-Web-API` project from the "Solution explorer" column, and pick properties. Go to the "Debug" section, which will contain an "Open debug launch profiles" link. Click it and you'll find an option to "launch the browser", which you want to leave **unticked**. Then, at the bottom, you want to find the option that says "Use SSL" followed by the url that will be used (showing the "port" to which it will respond). If that URL is _not_ "https://localhost:44344" (and you can't set it to this value), then you'll need to edit the "APIUrl.txt" file.


### Client APP: what you need to know
It's a vanilla Angular App, which you can start from the command line "npm start", or from VS itself. It won't work if the corresponding API isn't "listening" (running), though. The Angular CLI ("ng [command] ...") if fully functional, which _should_ make upgrading, and the creation of Angular Unit Tests easier, from now on. 

On the other hand, adding npm packages, although it _should_ work reliably (Either: `ng add [package]` or `npm --install --save [package]`), is really fragile. Given the number of packages we have installed, sometimes things go wrong and produce thousands of compiler errors, which are difficult to parse as they happen on the console terminal, instead of VS errors list.

Moreover, when developing ER-Web in the standard/recommended way, the Angular CLI "npm start" command line window **does not close automatically** when one stops debugging. So, if you stopped debugging _because_ you wanted the Angular App to restart (for whatever reason), **you have to remember** to close the CLI command window manually.

The client project is configured to use the "Hot Module Replacement" system which is now part of Angular core facilities (previously: you had to "implement it" on your own via WebPack). At the time of writing, I'm still not sure if it is actually rebuilding all components that use a given "updated" one (partent/children and or "injected service" relations are everywhere!), I suspect it doesn't, which means that pressing "F5" to get a full refresh might be useful often.


### API: what you need to know
Hard to say! Project is configured to use https:// so hopefully at the first run, VS will ask if you want to use a self-signed certificate for this, to which **you should** answer YES. You also want to check that it's listening to port 44344, OR change the `\src\assets\APIUrl.txt` in the client to match the port you're using (which will cascade problems to _other_ developers, though).

# How to: recommended settings
In most cases, you will want to click "debug(play)" once, get both projects started and then rely on hot-module-replacement to keep the angular side up-to-date. For this you can use the `Debug\Set startup project` dialog (from the VS menus).

You would pick "multiple startup projects", and have both client and api projects set with "start", making sure the API proj appears first.

If/when you'll need to _restart_ the API (to apply changes) restarting the whole app _will not_ recuild the client (if you didn't close the corresponding Angular CLI command window explictily), which makes such restarts faster. Moreover, if you opened up a _separate_ browser window and used that to interact with the client (not the window opened by VS!), clicking "restart" won't close it, which makes the whole process painless.

The downside is that when you click "Stop" the Angular CLI process that "serves" the angular app does not shut down (the command window remains!), so when you need to actually stop/restart the Angular app entirely (for example, if you want to install new npm packages) **you have to remember** to close the command window manually!

To be entirely "free" to change both ends and have minimal delays, you can also start the angular project from the command line, and the API project from VS. You then need to manually browse to `http://localhost:4200/` but at this point, changing things on the API project and clicking "restart" will _only_ restart the API project, wich will be fast. 

For the Angular side, unless you need to add new modules or npm packages, the "Hot Module Replacement" mechanism should work, allowing to update the client automatically when you save a file change.


